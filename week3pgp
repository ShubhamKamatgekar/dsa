1.Wave Array:
-----------
Given an sorted array arr[] of integers. Sort the array into a wave-like array(In Place). In other words, arrange the elements into a sequence such that arr[1] >= arr[2] <= arr[3] >= arr[4] <= arr[5] ..... and so on. If there are multiple solutions, find the lexicographically smallest one.

Note: The given array is sorted in ascending order, and modify the given array in-place without returning a new array.

Examples:

Input: arr[] = [1, 2, 3, 4, 5]
Output: [2, 1, 4, 3, 5]
Explanation: Array elements after sorting it in the waveform are 2, 1, 4, 3, 5.
Input: arr[] = [2, 4, 7, 8, 9, 10]
Output: [4, 2, 8, 7, 10, 9]
Explanation: Array elements after sorting it in the waveform are 4, 2, 8, 7, 10, 9.
Input: arr[] = [1]
Output: [1]
Constraints:
1 ≤ arr.size ≤ 106
0 ≤ arr[i] ≤109

Expected Complexities
Time Complexity: O(n)
Auxiliary Space: O(1)
Company Tags
PaytmFlipkartAmazonMicrosoftFactSetGoldman SachsGoogle
Topic Tags
ArraysSortingData StructuresAlgorithms

class Solution {
  public:
    void sortInWave(vector<int>& arr) {
        // code here
        int n = arr.size();
        int i=0;
        int j=1;
        
        while(i<n && j<n) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i+=2;
            j+=2;
        }
    }
};

3.Wave Array
---------------
You are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.

Examples:

Input: arr[] = [1, 2, 3, 5]
Output: 4
Explanation: All the numbers from 1 to 5 are present except 4.
Input: arr[] = [8, 2, 4, 5, 3, 7, 1]
Output: 6
Explanation: All the numbers from 1 to 8 are present except 6.
Input: arr[] = [1]
Output: 2
Explanation: Only 1 is present so the missing element is 2.
Constraints:
1 ≤ arr.size() ≤ 106
1 ≤ arr[i] ≤ arr.size() + 1

Expected Complexities
Company Tags
FlipkartMorgan StanleyAccoliteAmazonMicrosoftD-E-ShawOla CabsPayuVisaIntuitAdobeCiscoQualcommTCS

class Solution {
  public:
    int missingNum(vector<int>& arr) {
        // code here
        int sum = 0;
        int n=arr.size();
        
        for (int i=0; i<n; i++) {
            //sum += arr[i];
            sum ^= arr[i];
        }
        
        // int tot = ((n+1)*(n+2))/2; //ned to handle nt limits as prod can be large
        // return tot-sum;
        int tot = sum;
        for (int i=1; i<=n+1; i++) {
            tot ^= i;
        }
        
        return tot;
    }
};


5.. Maximum Nesting Depth of the Parentheses:
---------------------------------------------
Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.

Example 1:
Input: s = "(1+(2*3)+((8)/4))+1"
Output: 3
Explanation:
Digit 8 is inside of 3 nested parentheses in the string.

Example 2:
Input: s = "(1)+((2))+(((3)))"
Output: 3
Explanation:
Digit 3 is inside of 3 nested parentheses in the string.

Example 3:
Input: s = "()(())((()()))"
Output: 3

Constraints:

1 <= s.length <= 100
s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
It is guaranteed that parentheses expression s is a VPS.

class Solution {
public:
    int maxDepth(string s) {
        int maxD = 0;
        int depth = 0;

        for (auto i:s) {
            if (i == '(') {
                depth++;
                maxD = max(depth, maxD);
            } else if (i == ')') {
                depth--;
            }
        }

        return maxD;
    }
};

6. Roman to Integer:
--------------------
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

Example 1:
Input: s = "III"
Output: 3
Explanation: III = 3.
Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 

Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].

class Solution {
public:
    int romanToInt(string s) {
        int val = 0;
        int n = s.size();
        for (int i=0; i<n; i++) {
            if (s[i] == 'I') {
                if (i+1 < n && s[i+1] == 'V') {
                    val += 4;
                    i++;
                } else if (i+1 < n && s[i+1] == 'X') {
                    val += 9;
                    i++;
                } else {
                    val++;
                }
            } else if (s[i] == 'X') {
                if (i+1 < n && s[i+1] == 'L') {
                    val += 40;
                    i++;
                } else if (i+1 < n && s[i+1] == 'C') {
                    val += 90;
                    i++;
                } else {
                    val+=10;
                }
            } else if (s[i] == 'C') {
                if (i+1 < n && s[i+1] == 'D') {
                    val += 400;
                    i++;
                } else if (i+1 < n && s[i+1] == 'M') {
                    val += 900;
                    i++;
                } else {
                    val+=100;
                }
            } else if (s[i] == 'V') {
                val += 5;
            } else if (s[i] == 'L') {
                val += 50;
            } else if (s[i] == 'D') {
                val += 500;
            } else if (s[i] == 'M') {
                val += 1000;
            }
        }

        return val;
    }
};

//using map
int romanToInt(string s) {
        unordered_map<char,int> st;
        st['I'] = 1 ;
        st['V'] = 5 ;
        st['X'] = 10 ; 
        st['L'] = 50 ; 
        st['C'] = 100; 
        st['D'] = 500; 
        st['M'] = 1000;

        int res = 0;
        for(int i=0;i<s.size();i++){
            if(st[s[i]] < st[s[i+1]]){
                res -= st[s[i]];
            }
            else
                res += st[s[i]];
        }
        return res ;
    }

7. Isomorphic Strings:
-----------------------
Given two strings s and t, determine if they are isomorphic.
Two strings s and t are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

Example 1:
Input: s = "egg", t = "add"
Output: true
Explanation:
The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:
Input: s = "foo", t = "bar"
Output: false
Explanation:
The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

Example 3:
Input: s = "paper", t = "title"
Output: true

Constraints:

1 <= s.length <= 5 * 104
t.length == s.length
s and t consist of any valid ascii character.

class Solution {
public:
/*
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> mp;
        int visited[256];
        int n1 = s.size();
        int n2 = t.size();
        if (n1 != n2) return false;

        for (int i=0; i<n1; i++) {
            if (mp.find(s[i]) != mp.end()) {
                if (t[i] != mp[s[i]]) return false;
            } else {
                if (visited[t[i]] != 0) return false;
                mp[s[i]] = t[i];
                visited[t[i]]++;
            }
        }

        return true;        
    }
    */

     bool isIsomorphic(string s, string t) {
        int n1 = s.size();
        int n2 = t.size();
        if (n1 != n2) return false;
        int visitedS[256];
        int visitedT[256];

        for (int i=0; i<n1; i++) {
            if (visitedT[t[i]] == 0) {
                visitedT[t[i]] = i+1;
            }
            if (visitedS[s[i]] == 0) {
                visitedS[s[i]] = i+1;
            }
            if (visitedS[s[i]] != visitedT[t[i]]) return false;
        }

        return true;
    }
};


8. Valid Anagram:
-----------------
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

Example 1:
Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false

Constraints:
1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.
 
Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

func isAnagram(s string, t string) bool {
    if (len(s) != len(t)) {
        return false
    }
    sm := make([]int, 256)
   // tm := make([]int, 256)

    for i:=0; i< len(s); i++ {
        sm[s[i]]++
       // tm[t[i]]++
    }
    for i:=0; i< len(t); i++ {
        sm[t[i]]--
       // tm[t[i]]++
    }
    for i:=0; i< 256; i++ {
        //if sm[i] != tm[i] {
        if sm[i] != 0 {
            return false
        }
    }

    return true
}

11. Rotate Array:
-----------------
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

Example 1:

Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
 
Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        if (n==1 || k==0) return;
        k = k %n;
        if (k>0) {
            reverse(nums.begin()+n-k, nums.end());
            reverse(nums.begin(), nums.begin()+n-k);
            reverse(nums.begin(), nums.end());
        }

    }
};

13. Sum of all Submatrices of a Given Matrix:
---------------------------------------------
Given a n * n 2D matrix, the task to find the sum of all the submatrices.

Examples: 

Input :  mat[][] = [[1, 1],
                         [1, 1]];
Output : 16
Explanation: 
Number of sub-matrices with 1 elements = 4
Number of sub-matrices with 2 elements = 4
Number of sub-matrices with 3 elements = 0
Number of sub-matrices with 4 elements = 1

Since all the entries are 1, the sum becomes
sum = 1 * 4 + 2 * 4 + 3 * 0 + 4 * 1 = 16

Input : mat[][] = [[1, 2, 3],
                         [4, 5, 6],
                        [7, 8, 9]]
Output : 500

[Naive Approach] Checking all Submatrices - O(n^6) Time and O(1) Space
The idea is to generate all the possible submatrices and add the sum of all its elements to the result.




// C++ program to find the sum of all possible submatrices
#include <iostream>
#include <vector>
using namespace std;
​
// Function to find the sum of all submatrices 
int matrixSum(vector<vector<int>>& matrix) {
    int n = matrix.size();
    int res = 0;
    
    // Iterate over all possible top-left corners
    for (int startRow = 0; startRow < n; startRow++) {
        for (int startCol = 0; startCol < n; startCol++) {
            
            // Iterate over all possible bottom-right corners
            for (int endRow = startRow; endRow < n; endRow++) {
                for (int endCol = startCol; endCol < n; endCol++) {
                    
                    // For each valid submatrix, calculate its sum
                    int submatrixSum = 0;
                    for (int i = startRow; i <= endRow; i++) {
                        for (int j = startCol; j <= endCol; j++) {
                            submatrixSum += matrix[i][j];
                        }
                    }
                    
                    // Add this submatrix sum to the total
                    res += submatrixSum;
                }
            }
        }
    }
    
    return res;
}
​
int main() {
    vector<vector<int>> matrix = {
        {1, 1},
        {1, 1}
    };
    
    cout << matrixSum(matrix);
    return 0;
}

Output
16
[Expected Approach] Using Reverse Lookup - O(n^2) Time and O(1) Space
The idea is to calculate the contribution of each element to the total sum by determining in how many different submatrices that element appears. We can directly compute how many submatrices contain each element in O(1) time and use this to find each element's total contribution to the sum. 

Step by step approach:

For each element at position (i ,j), calculate how many different top-left corners could form a submatrix containing it: (i+1)*(j+1).
Calculate how many different bottom-right corners could form a submatrix containing it: (n-i)*(n-j).
The total number of submatrices containing this element is the product: (i + 1)(j + 1)(n - i)*(n - j).
Multiply this count by the element's value to get its total contribution to the sum.
Illustration:

Taking example of matrix:
[1 2 3] 
[4 5 6] 
[7 8 9]

Let's consider the element 5 at position (1,1) in a 3×3 matrix:

Possible top-left corners: (0,0), (0,1), (1,0), (1,1) → (1+1)*(1+1) = 4 possibilities
Possible bottom-right corners: (1,1), (1,2), (2,1), (2,2) → (3-1)*(3-1) = 4 possibilities
Total submatrices containing 5: 4×4 = 16 submatrices
Total contribution of element 5 to the sum: 5×16 = 80



// C++ program to find the sum of all possible submatrices
#include <iostream>
#include <vector>
using namespace std;
​
// Function to find the sum of all submatrices 
int matrixSum(vector<vector<int>>& matrix) {
    int n = matrix.size();
    int res = 0;
    
    // Iterate through each element in the matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            
            // Number of ways to choose the top-left corner 
            int topLeft = (i + 1) * (j + 1);
            
            // Number of ways to choose the bottom-right corner
            int bottomRight = (n - i) * (n - j);
            
            // Calculate contribution of current element
            res += (topLeft * bottomRight * matrix[i][j]);
        }
    }
    
    return res;
}
​
int main() {
    vector<vector<int>> matrix = {
        {1, 1},
        {1, 1}
    };
    
    cout << matrixSum(matrix);
    return 0;
}

Output
16


14.  Search a 2D Matrix II:
-----------------------------
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

example 1:
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true

example 2:
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false

class Solution {
public:
/*
    bool check(vector<vector<int>>& matrix, int row, int n, int target) {
        int low = 0;
        int high = n-1;
        
        while (low <= high) {
            int mid = (low + high) / 2;
            if (matrix[row][mid] == target) {
                return true;
            }

            if (matrix[row][mid] > target) {
                high = mid-1;
            } else {
                low = mid+1;
            }
        }

        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();

        for (int i=0; i<m; i++) {
            if (target >= matrix[i][0] && target <= matrix[i][n-1]) {
                if (check(matrix, i, n, target)) {
                    return true;
                }
            }
        }

        return false;
    }
    */
//INTERVIEWER'S LOVE THIS top-right stratergy
/*
Start at the top-right cell.
If the current value is greater than the target, move left.
If less, move down.
Repeat until found or bounds exceeded.
*/
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int r=0;
        int c=n-1;

        while (r<m && c>=0) {
            if (matrix[r][c] == target) return true;
            if (matrix[r][c] > target)  {
                c--;
                //if (c==-1) {
                  //  c=n-1;
                   // r++;
                //}
            } else if (matrix[r][c] < target) {
                r++;
            }    
        }

        return false;
    }
};


15. Modify an array such that if 'arr[i]' is 'j' then arr[j] becomes i:
-----------------------------------------------------------------------
Given an array arr[] of size n, where all elements are distinct and fall within the range 0 to n-1. The task is to modify arr[] such that if arr[i] = j, then it gets transformed into arr[j] = i.

Examples: 

Input: arr[] = [1, 3, 0, 2]
Output: 2 0 3 1
Explanation: Since arr[0] = 1, update arr[1] to 0
Since arr[1] = 3, update arr[3] to 1
Since arr[2] = 0, update arr[0] to 2
Since arr[3] = 2, update arr[2] to 3

Input: arr[] = [2, 0, 1, 4, 5, 3]
Output: 1 2 0 5 3 4
Explanation: Since arr[0] = 2, update arr[2] to 0
Since arr[1] = 0, update arr[0] to 1
Since arr[2] = 1, update arr[1] to 2
Since arr[3] = 4, update arr[4] to 3
Since arr[4] = 5, update arr[5] to 4
Since arr[5] = 3, update arr[3] to 5

Input: arr[] = [3, 2, 1, 0]
Output: 3 2 1 0
Explanation: Since each element is already at its correct index, the array remains unchanged.

[Brute Force Approach] Using an Extra Array - O(n) Time and O(n) Space
The idea is to use an extra array to directly place each element at its correct index without modifying the input during traversal. By observing that each element arr[i] represents its future index, we create a newArr where newArr[arr[i]] = i. Finally, we copy newArr back to arr to complete the rearrangement efficiently.




// C++ Code to Rearrange Array Elements
// using an Extra Array 
#include <bits/stdc++.h>
using namespace std;
​
void rearrange(vector<int>& arr) {
​
    int n = arr.size();
    
    // Create an auxiliary array to
    // store new values
    vector<int> newArr(n);
​
    // Place each element at its correct index
    for (int i = 0; i < n; i++) {  
        newArr[arr[i]] = i;
    }
​
    // Copy modified values back to the 
    // original array
    for (int i = 0; i < n; i++) {  
        arr[i] = newArr[i];
    }
}
​
​
int main() {
​
    vector<int> arr = {2, 0, 1, 4, 5, 3};
​
    rearrange(arr); 
    
    for (int x : arr) {  
        cout << x << " ";
    }
    
    return 0;
}

Output
1 2 0 5 3 4 

[Expected Approach 2] Using Modulo - O(n) Time and O(1) Space
The idea is to store both the old and new values within the same array using modulo and multiplication. Each element is updated such that arr[arr[i] % n] accumulates the new position while preserving the original value. After processing, the new values are extracted by performing integer division with n. This ensures an in-place transformation without using extra space. 




// C++ Code to Rearrange Array Elements
// using modulo
#include <bits/stdc++.h>
using namespace std;
​
// Rearrange arr[] so that arr[j] 
// becomes i if arr[i] is j
void rearrange(vector<int>& arr) {
​
    int n = arr.size();
​
    // Store new values using modulo
    for (int i = 0; i < n; i++) {  
        arr[arr[i] % n] += i * n;
    }
​
    // Extract new values
    for (int i = 0; i < n; i++) {  
        arr[i] /= n;
    }
}
​
int main() {
​
    vector<int> arr = {2, 0, 1, 4, 5, 3};
​
    rearrange(arr); 
    
    for (int x : arr) {  
        cout << x << " ";
    }
​
    return 0;
}

Output
1 2 0 5 3 4 



16. Permutation in String
--------------------------
Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
In other words, return true if one of s1's permutations is the substring of s2.

Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:

Input: s1 = "ab", s2 = "eidboaoo"
Output: false
 
Constraints:

1 <= s1.length, s2.length <= 104
s1 and s2 consist of lowercase English letters.

//this que is an example of sliding window pattern)
bool checkInclusion(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        if (n1 > n2) return false;

        vector<int> ms1(26, 0);
        for (auto c:s1) ms1[c-'a']++;

        vector<int> ms2(26, 0);
//use sliding window from i to j and check if this window matches any permby comparing the freq else dec ith freq in m2 and check for next window.
        int i=0;
        int j=0;
        while (j<n2) {
            ms2[s2[j]-'a']++;
            if (j-i+1 == n1) {
                if (ms2 == ms1) return true;
            } 
            
            if (j-i+1 < n1) {
                j++;
            } else {
                ms2[s2[i]-'a']--;
                i++;
                j++;
            }
        }

        return false;
    }

17. Majority Element II:
-----------------------
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 
Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        if (n==1) return nums;
        
        int a = 0;
        int b = 0;
        int ac = 0;
        int bc = 0;
        for (auto i: nums) {
            if (a==i)  {
                ac++;
            } else if (b==i) {
                bc++;
            } else if (ac==0) {
                a=i;
                ac++;
            } else if (bc==0) {
                b=i;
                bc++;
            } else {
                ac--;
                bc--;
            }
        }

        vector<int> ans;
        ac = 0;
        bc = 0;
        for (auto k: nums) {
            if (k==a) ac++;
            else if (k==b) bc++;
        }
        if (ac > (n/3)) ans.push_back(a);
        if (bc > (n/3)) ans.push_back(b);

        return ans;
    }
};
 
18 . Find the Duplicate Number:
---------------------------------
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and using only constant extra space.

Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

Example 3:
Input: nums = [3,3,3,3,3]
Output: 3

Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.


(this que is an example of fast and slow ptr(tortoise hare or floyd's cycle detection method)
/* o(n) but array modified
    int findDuplicate(vector<int>& nums) {
        int n = nums.size();
        for (int i=0; i<n; i++) {
            if (nums[abs(nums[i]) - 1] > 0) {
                nums[abs(nums[i]) - 1] *= -1;
            } else {
                return abs(nums[i]);
            }
        }

        return 0;
    }
   */ 
//fast and slow pointer (floyd's tortoise hare)
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0];
        int fast = nums[0];

        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        slow = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }


23. Rearrange Array Alternately:
---------------------------------
Given an array of positive integers. Your task is to rearrange the array elements alternatively i.e. first element should be the max value, the second should be the min value, the third should be the second max, the fourth should be the second min, and so on.
Note: Modify the original array itself. Do it without using any extra space. You do not have to return anything.

Examples:
Input: arr[] = [1, 2, 3, 4, 5, 6]
Output: [6, 1, 5, 2, 4, 3]
Explanation: Max element = 6, min = 1, second max = 5, second min = 2, and so on... The modified array is: [6, 1, 5, 2, 4, 3]

Input: arr[]= [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110]
Output: [110, 10, 100, 20, 90, 30, 80, 40, 70, 50, 60]
Explanation: Max element = 110, min = 10, second max = 100, second min = 20, and so on... Modified array is : [110, 10, 100, 20, 90, 30, 80, 40, 70, 50, 60]
Input: arr[]= [1]
Output: [1]

Constraints:
1 ≤ arr.size ≤ 106
1 ≤ arr[i] ≤ 106

Expected Complexities
Time Complexity: O(n log n)
Auxiliary Space: O(1)
Company Tags : Zoho

//this is an exampl of storing two alues at one place (modifying he array) pattern
//the max shud be 1 greater to avoid moudlo becoming 0

void rearrange(vector<int>& arr) {
        int m = arr.size();
        int count = 0;
        int j = 0;
        int k = m-1;
        sort(arr.begin(), arr.end());
        int n = arr[m-1]+1; //add 1 because n % n will give 0 so 
        arr[0] = arr[0] + arr[k] *n;
        k--;
       
        for (int i=1; i<m; i++) {
            if (i%2 == 0 && k>=0) {
                arr[i] = (arr[i]%n) + (arr[k]%n) * n;
                k--;
            }
            if (i%2 == 1 && j<m) {
                arr[i] = (arr[i]%n) + ((arr[j]%n) * n);
                j++;
            }
        }
        
        for (int i=0; i<m; i++) {
            arr[i] = arr[i] / n;
        }
    }


24. Number of Valid Parentheses Expressions : 
--------------------------------------------
Given an integer n, find the number of valid parentheses expressions of length n.

Examples : 
Input: n = 2
Output: 1 
Explanation: There is only one possible valid expression of length 2, "()"

Input: n = 4
Output: 2 
Explanation: Possible valid expression of length 4 are "(())" and "()()" 

Input: n = 6
Output: 5
Explanation: Possible valid expressions are "((()))", "()(())", "()()()", "(())()" and "(()())"
(this problem is n example of catalan nos)

soln:
-----
Do we really need to generate the entire string like "(())" ?

To count the number of valid parentheses, it is enough to keep track of the number of opening and closing brackets left to place. We don’t care about the exact string unless we want to print all arrangements—just the counts are enough to ensure validity.

The idea is to place the opening and closing brackets while maintaining validity. At each step, we can either place an opening bracket (if any are left) or a closing bracket (only if the number of remaining closing brackets is greater than the number of remaining opening brackets). This ensures that the partially formed string is always valid, and by recursively exploring these choices and count all possible valid arrangements.




#include <iostream>
using namespace std;
​
// Recursive function to count the valid ways
int countValid(int open, int close) {
    
    // Invalid case
    if (close < open)
        return 0;
​
    if (!open)
        return 1;
​
    return countValid(open - 1, close) + countValid(open, close - 1);
}
​
// Function to count valid parentheses
// arrangements of length n
int findWays(int n) {
    
    // If n is odd, no valid arrangements possible
    if (n % 2 == 1)
        return 0;
    return countValid(n / 2, n / 2);
}
​
int main() {
    int n = 6;
    int res = findWays(n);
    cout << res << endl;
    return 0;
}

Output
5

[Expected Approach] Using Dynamic Programming (Catalan Numbers) - O(n) Time and O(1) Space
If n is odd, it is impossible to form valid parentheses because parentheses always come in pairs. If n is even, there are n/2 pairs of parentheses so the problem reduces to arranging these n/2 pairs in all possible valid ways.

The idea is to use Catalan number to find the number of ways to arrange n/2 pairs of parentheses so that the resulting sequence is valid. 

The nth Catalan number can be calculated using the formula:
Cn = 2n!/(n+1)!*n!
which can be written in binomial coeff as (2n) (1/n+1) i.e -- 2n/1 * (2n-1)/2 * (2n-2)/3 * ... (2n-(n-1))/n
                                            n


#include <iostream>
using namespace std;
​
// function to find of Binomial Coefficient C(n, k)
int binomialCoeff(int n, int k) {
    int res = 1;
​
    // Since C(n, k) = C(n, n-k)
    if (k > n - k)
        k = n - k;
        
    for (int i = 0; i < k; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
​
    return res;
}
​
// A Binomial coefficient based function to
// find nth catalan number in O(n) time
int catalan(int n) {
  
    // Calculate value of 2nCn
    int c = binomialCoeff(2 * n, n);
​
    // return 2nCn/(n+1)
    return c / (n + 1);
}
​
// Function to find possible ways
int findWays(int n) {
    if (n & 1)
        return 0;
    return catalan(n / 2);
}
​
int main() {
    int n = 6;
    cout << findWays(n);
    return 0;
}

Output
5


25. Sort Characters By Frequency:
-----------------------------------
Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

Return the sorted string. If there are multiple answers, return any of them.

Example 1:
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

Example 2:
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.

Example 3:
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
 
Constraints:
1 <= s.length <= 5 * 105
s consists of uppercase and lowercase English letters and digits.

(this problm is  a pattern of freq)
string frequencySort(string s) {
        unordered_map<char, int> mp;
        for (auto c : s) {
            mp[c]++;
        }
        vector<pair<char, int>> freq;
        for (auto i: mp) {
            freq.push_back({i.first, i.second});
        }

        sort(freq.begin(), freq.end(), [](auto &a, auto &b) {
            return a.second > b.second;
        });

        string res = "";
        for (auto c : freq) {
            while (c.second != 0){
                res.push_back(c.first);
                c.second--;
            }
        }
        return res;
    }


27. Reverse Words in a String:
-----------------------------
Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space.

Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

Example 1:
Input: s = "the sky is blue"
Output: "blue is sky the"

Example 2:
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.

Example 3:
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
 
Constraints:
1 <= s.length <= 104
s contains English letters (upper-case and lower-case), digits, and spaces ' '.
There is at least one word in s.
 
Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?

class Solution {
public:
    string reverseWords(string s) {
        int i=0;

        while(s[i] == ' ') {
            s.erase(i, 1);
        }

        reverse(s.begin(), s.end());

        while(s[i] == ' ') {
            s.erase(i, 1);
        }
        
        int j=0;
        while(j < s.size()) {
            while(j < s.size() && s[j] != ' ') j++;
            reverse(s.begin()+i, s.begin()+j);
            j++;
            i=j;
            while(i<s.size() && s[i] == ' ') {
                s.erase(i, 1);
            }
            j=i;
        }

        return s;
    }
};


28. 8. String to Integer (atoi)
Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.

The algorithm for myAtoi(string s) is as follows:

Whitespace: Ignore any leading whitespace (" ").
Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.
Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.
Return the integer as the final result.

 
Example 1:
Input: s = "42"
Output: 42
Explanation:
The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)
           ^

Example 2:
Input: s = " -042"
Output: -42
Explanation:
Step 1: "   -042" (leading whitespace is read and ignored)
            ^
Step 2: "   -042" ('-' is read, so the result should be negative)
             ^
Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)
               ^

Example 3:
Input: s = "1337c0d3"
Output: 1337
Explanation:
Step 1: "1337c0d3" (no characters read because there is no leading whitespace)
         ^
Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)
             ^

Example 4:
Input: s = "0-1"
Output: 0
Explanation:
Step 1: "0-1" (no characters read because there is no leading whitespace)
         ^
Step 2: "0-1" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)
          ^

Example 5:
Input: s = "words and 987"
Output: 0

Explanation:
Reading stops at the first non-digit character 'w'.

Constraints:
0 <= s.length <= 200
s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.

class Solution {
public:
    int myAtoi(string s) {
        int n = s.size();
        int i=0;
        while (i<n && s[i] == ' ') i++;
        long long ans = 0;
        bool neg = false;
        if (s[i] == '-') {
            neg = true;
            i++;
        } else if (s[i] == '+') i++;
        if (!(s[i] >= '0' &&  s[i] <= '9')) return 0;
        while (i<n && s[i] == '0') i++;
        while (i<n) {
            if (s[i] >= '0' &&  s[i] <= '9') {
                ans += s[i]-'0';
                i++;
                if (i<n && (s[i] >= '0' &&  s[i] <= '9')) {
                    if (i<n && ans > (INT_MAX/10)) {
                        if (neg) return INT_MIN;
                        else return INT_MAX;
                    } 
                    ans *= 10;
                }
            } else {
                break;
            }
        }
        if (neg) {
            ans *= -1;
        }
        if (ans < INT_MIN) return INT_MIN;
        if (ans > INT_MAX) return INT_MAX;
        return ans;
    }
};

29. Permutation Sequence:
----------------------------
The set [1, 2, 3, ..., n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Example 1:
Input: n = 3, k = 3
Output: "213"

Example 2:
Input: n = 4, k = 9
Output: "2314"

Example 3:
Input: n = 3, k = 1
Output: "123"
 
Constraints:
1 <= n <= 9
1 <= k <= n!

class Solution {
public:
/*
   // int ct;
    void getPerm(int i, int n, string &val, int k, unordered_set<string> &res) {
        // if (k==0) {
        //     return;
        // }
        if (i==n) {
            res.insert(val);
           // ct--;
            return;
        }

        //if (ct == 0) return;
        for (int j=i; j<n; j++) {
            //if (i!=j) {
                swap(val[i], val[j]);
                //cout<<"val "<< val<<" k "<<k<<endl;
                // res.insert(val);
                getPerm(i+1, n, val, k-1, res);
                swap(val[i], val[j]);
            //}
        }
    }

    string getPermutation(int n, int k) {
        string val = "";
        for (int i=1; i<=n; i++) {
            val.push_back(i+'0');
        }
    //    ct=k;
        unordered_set<string> res;
        res.insert(val);
        getPerm(0, n, val, k, res);
        
        vector<string> ans(res.begin(), res.end());
        sort(ans.begin(), ans.end());
        for (int i=0; i<ans.size(); i++) {
            cout<<ans[i]<<endl;
        }
        return ans[k-1];
    }

*/

    string getPermutation(int n, int k) {
        vector<int> nums;
        int fact = 1;
        for (int i=1;i<n; i++) {
            fact = fact*i; //fact for n 1 less because a particular pos can be filled wit (n-1) ! ways
            nums.push_back(i);
        }

        nums.push_back(n);
        k = k-1; //0 based indicing
        string ans = "";
        while (true) {
            int num = nums[k/fact];
            ans.push_back('0' + num);
            nums.erase(nums.begin()+(k/fact));

            n = nums.size();
            if (n==0) break;

            k=k%fact;
            fact = fact/n;
        }

        return ans;
    }
};


30. Maximum Gap:
-------------------
Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.
You must write an algorithm that runs in linear time and uses linear extra space.

Example 1:
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.

Example 2:
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
 
Constraints:
1 <= nums.length <= 105
0 <= nums[i] <= 109

//belongs to bucket sort pattern
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int n = nums.size();
        if (n<2) return 0;
        if (n==2) return abs(nums[1]-nums[0]);
        /*
        int maxi = 0;
        sort(nums.begin(), nums.end());
        for (int i=1; i<n; i++) {
            maxi = max(maxi, nums[i] - nums[i-1]);
        }

        return maxi;
        */

        int mini = *min_element(nums.begin(), nums.end());
        int maxi = *max_element(nums.begin(), nums.end());

        int diff = maxi-mini;
        if (diff == 0) return 0;
        int bucketSize = ceil(double(diff)/(n-1));
        int bucketCount = diff/bucketSize + 1;
        int maxdiff = 0;

        vector<pair<int, int>> bucket(bucketCount, {INT_MAX, INT_MIN});
        for (int i=0; i<n; i++) {
           int idx = (nums[i]-mini)/bucketSize;
           bucket[idx].first = min(bucket[idx].first, nums[i]);
           bucket[idx].second = max(bucket[idx].second, nums[i]);
        }

        int prev = mini;
        for (int i=0; i<bucketCount; i++) {
            if (bucket[i].first == INT_MAX) continue;//no ele in bucket so skip
            int curMini = bucket[i].first;
            maxdiff = max(maxdiff, curMini - prev);
            prev = bucket[i].second;
        }
        return maxdiff;
    }
};


31. Longest Palindromic Substring:
------------------------------------
Given a string s, return the longest palindromic substring in s.

Example 1:
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:
Input: s = "cbbd"
Output: "bb"
 
Constraints:
1 <= s.length <= 1000
s consist of only digits and English letters.


class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n==1) return s;
        string ans = "";
        int maxi = 0;
        int start = 0;
    
        for (int i = 0; i<n; i++) {
            for (int j = 0; j <= 1; j++) { //can be even or odd
                int low = i;
                int high = i+j;
                while (low >= 0 && high < n && s[low] == s[high]) {
                    int currlen = high-low+1;
                    if (currlen > maxi) {
                        start = low;
                        maxi = high-low+1;
                    }
                    low--;
                    high++;
                }
            }
        }
        
        return s.substr(start, maxi);
    }
};


1.Wave Array:
-----------
Given an sorted array arr[] of integers. Sort the array into a wave-like array(In Place). In other words, arrange the elements into a sequence such that arr[1] >= arr[2] <= arr[3] >= arr[4] <= arr[5] ..... and so on. If there are multiple solutions, find the lexicographically smallest one.

Note: The given array is sorted in ascending order, and modify the given array in-place without returning a new array.

Examples:

Input: arr[] = [1, 2, 3, 4, 5]
Output: [2, 1, 4, 3, 5]
Explanation: Array elements after sorting it in the waveform are 2, 1, 4, 3, 5.
Input: arr[] = [2, 4, 7, 8, 9, 10]
Output: [4, 2, 8, 7, 10, 9]
Explanation: Array elements after sorting it in the waveform are 4, 2, 8, 7, 10, 9.
Input: arr[] = [1]
Output: [1]
Constraints:
1 ≤ arr.size ≤ 106
0 ≤ arr[i] ≤109

Expected Complexities
Time Complexity: O(n)
Auxiliary Space: O(1)
Company Tags
PaytmFlipkartAmazonMicrosoftFactSetGoldman SachsGoogle
Topic Tags
ArraysSortingData StructuresAlgorithms

class Solution {
  public:
    void sortInWave(vector<int>& arr) {
        // code here
        int n = arr.size();
        int i=0;
        int j=1;
        
        while(i<n && j<n) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i+=2;
            j+=2;
        }
    }
};

3.Wave Array
---------------
You are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.

Examples:

Input: arr[] = [1, 2, 3, 5]
Output: 4
Explanation: All the numbers from 1 to 5 are present except 4.
Input: arr[] = [8, 2, 4, 5, 3, 7, 1]
Output: 6
Explanation: All the numbers from 1 to 8 are present except 6.
Input: arr[] = [1]
Output: 2
Explanation: Only 1 is present so the missing element is 2.
Constraints:
1 ≤ arr.size() ≤ 106
1 ≤ arr[i] ≤ arr.size() + 1

Expected Complexities
Company Tags
FlipkartMorgan StanleyAccoliteAmazonMicrosoftD-E-ShawOla CabsPayuVisaIntuitAdobeCiscoQualcommTCS

class Solution {
  public:
    int missingNum(vector<int>& arr) {
        // code here
        int sum = 0;
        int n=arr.size();
        
        for (int i=0; i<n; i++) {
            //sum += arr[i];
            sum ^= arr[i];
        }
        
        // int tot = ((n+1)*(n+2))/2; //ned to handle nt limits as prod can be large
        // return tot-sum;
        int tot = sum;
        for (int i=1; i<=n+1; i++) {
            tot ^= i;
        }
        
        return tot;
    }
};


5.. Maximum Nesting Depth of the Parentheses:
---------------------------------------------
Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.

Example 1:
Input: s = "(1+(2*3)+((8)/4))+1"
Output: 3
Explanation:
Digit 8 is inside of 3 nested parentheses in the string.

Example 2:
Input: s = "(1)+((2))+(((3)))"
Output: 3
Explanation:
Digit 3 is inside of 3 nested parentheses in the string.

Example 3:
Input: s = "()(())((()()))"
Output: 3

Constraints:

1 <= s.length <= 100
s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
It is guaranteed that parentheses expression s is a VPS.

class Solution {
public:
    int maxDepth(string s) {
        int maxD = 0;
        int depth = 0;

        for (auto i:s) {
            if (i == '(') {
                depth++;
                maxD = max(depth, maxD);
            } else if (i == ')') {
                depth--;
            }
        }

        return maxD;
    }
};

6. Roman to Integer:
--------------------
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

Example 1:
Input: s = "III"
Output: 3
Explanation: III = 3.
Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 

Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].

class Solution {
public:
    int romanToInt(string s) {
        int val = 0;
        int n = s.size();
        for (int i=0; i<n; i++) {
            if (s[i] == 'I') {
                if (i+1 < n && s[i+1] == 'V') {
                    val += 4;
                    i++;
                } else if (i+1 < n && s[i+1] == 'X') {
                    val += 9;
                    i++;
                } else {
                    val++;
                }
            } else if (s[i] == 'X') {
                if (i+1 < n && s[i+1] == 'L') {
                    val += 40;
                    i++;
                } else if (i+1 < n && s[i+1] == 'C') {
                    val += 90;
                    i++;
                } else {
                    val+=10;
                }
            } else if (s[i] == 'C') {
                if (i+1 < n && s[i+1] == 'D') {
                    val += 400;
                    i++;
                } else if (i+1 < n && s[i+1] == 'M') {
                    val += 900;
                    i++;
                } else {
                    val+=100;
                }
            } else if (s[i] == 'V') {
                val += 5;
            } else if (s[i] == 'L') {
                val += 50;
            } else if (s[i] == 'D') {
                val += 500;
            } else if (s[i] == 'M') {
                val += 1000;
            }
        }

        return val;
    }
};

//using map
int romanToInt(string s) {
        unordered_map<char,int> st;
        st['I'] = 1 ;
        st['V'] = 5 ;
        st['X'] = 10 ; 
        st['L'] = 50 ; 
        st['C'] = 100; 
        st['D'] = 500; 
        st['M'] = 1000;

        int res = 0;
        for(int i=0;i<s.size();i++){
            if(st[s[i]] < st[s[i+1]]){
                res -= st[s[i]];
            }
            else
                res += st[s[i]];
        }
        return res ;
    }

7. Isomorphic Strings:
-----------------------
Given two strings s and t, determine if they are isomorphic.
Two strings s and t are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

Example 1:
Input: s = "egg", t = "add"
Output: true
Explanation:
The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:
Input: s = "foo", t = "bar"
Output: false
Explanation:
The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

Example 3:
Input: s = "paper", t = "title"
Output: true

Constraints:

1 <= s.length <= 5 * 104
t.length == s.length
s and t consist of any valid ascii character.

class Solution {
public:
/*
    bool isIsomorphic(string s, string t) {
        unordered_map<char, char> mp;
        int visited[256];
        int n1 = s.size();
        int n2 = t.size();
        if (n1 != n2) return false;

        for (int i=0; i<n1; i++) {
            if (mp.find(s[i]) != mp.end()) {
                if (t[i] != mp[s[i]]) return false;
            } else {
                if (visited[t[i]] != 0) return false;
                mp[s[i]] = t[i];
                visited[t[i]]++;
            }
        }

        return true;        
    }
    */

     bool isIsomorphic(string s, string t) {
        int n1 = s.size();
        int n2 = t.size();
        if (n1 != n2) return false;
        int visitedS[256];
        int visitedT[256];

        for (int i=0; i<n1; i++) {
            if (visitedT[t[i]] == 0) {
                visitedT[t[i]] = i+1;
            }
            if (visitedS[s[i]] == 0) {
                visitedS[s[i]] = i+1;
            }
            if (visitedS[s[i]] != visitedT[t[i]]) return false;
        }

        return true;
    }
};


8. Valid Anagram:
-----------------
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

Example 1:
Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false

Constraints:
1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.
 
Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

func isAnagram(s string, t string) bool {
    if (len(s) != len(t)) {
        return false
    }
    sm := make([]int, 256)
   // tm := make([]int, 256)

    for i:=0; i< len(s); i++ {
        sm[s[i]]++
       // tm[t[i]]++
    }
    for i:=0; i< len(t); i++ {
        sm[t[i]]--
       // tm[t[i]]++
    }
    for i:=0; i< 256; i++ {
        //if sm[i] != tm[i] {
        if sm[i] != 0 {
            return false
        }
    }

    return true
}

11. Rotate Array:
-----------------
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

Example 1:

Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
 
Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        if (n==1 || k==0) return;
        k = k %n;
        if (k>0) {
            reverse(nums.begin()+n-k, nums.end());
            reverse(nums.begin(), nums.begin()+n-k);
            reverse(nums.begin(), nums.end());
        }

    }
};

13. Sum of all Submatrices of a Given Matrix:
---------------------------------------------
Given a n * n 2D matrix, the task to find the sum of all the submatrices.

Examples: 

Input :  mat[][] = [[1, 1],
                         [1, 1]];
Output : 16
Explanation: 
Number of sub-matrices with 1 elements = 4
Number of sub-matrices with 2 elements = 4
Number of sub-matrices with 3 elements = 0
Number of sub-matrices with 4 elements = 1

Since all the entries are 1, the sum becomes
sum = 1 * 4 + 2 * 4 + 3 * 0 + 4 * 1 = 16

Input : mat[][] = [[1, 2, 3],
                         [4, 5, 6],
                        [7, 8, 9]]
Output : 500

[Naive Approach] Checking all Submatrices - O(n^6) Time and O(1) Space
The idea is to generate all the possible submatrices and add the sum of all its elements to the result.




// C++ program to find the sum of all possible submatrices
#include <iostream>
#include <vector>
using namespace std;
​
// Function to find the sum of all submatrices 
int matrixSum(vector<vector<int>>& matrix) {
    int n = matrix.size();
    int res = 0;
    
    // Iterate over all possible top-left corners
    for (int startRow = 0; startRow < n; startRow++) {
        for (int startCol = 0; startCol < n; startCol++) {
            
            // Iterate over all possible bottom-right corners
            for (int endRow = startRow; endRow < n; endRow++) {
                for (int endCol = startCol; endCol < n; endCol++) {
                    
                    // For each valid submatrix, calculate its sum
                    int submatrixSum = 0;
                    for (int i = startRow; i <= endRow; i++) {
                        for (int j = startCol; j <= endCol; j++) {
                            submatrixSum += matrix[i][j];
                        }
                    }
                    
                    // Add this submatrix sum to the total
                    res += submatrixSum;
                }
            }
        }
    }
    
    return res;
}
​
int main() {
    vector<vector<int>> matrix = {
        {1, 1},
        {1, 1}
    };
    
    cout << matrixSum(matrix);
    return 0;
}

Output
16
[Expected Approach] Using Reverse Lookup - O(n^2) Time and O(1) Space
The idea is to calculate the contribution of each element to the total sum by determining in how many different submatrices that element appears. We can directly compute how many submatrices contain each element in O(1) time and use this to find each element's total contribution to the sum. 

Step by step approach:

For each element at position (i ,j), calculate how many different top-left corners could form a submatrix containing it: (i+1)*(j+1).
Calculate how many different bottom-right corners could form a submatrix containing it: (n-i)*(n-j).
The total number of submatrices containing this element is the product: (i + 1)(j + 1)(n - i)*(n - j).
Multiply this count by the element's value to get its total contribution to the sum.
Illustration:

Taking example of matrix:
[1 2 3] 
[4 5 6] 
[7 8 9]

Let's consider the element 5 at position (1,1) in a 3×3 matrix:

Possible top-left corners: (0,0), (0,1), (1,0), (1,1) → (1+1)*(1+1) = 4 possibilities
Possible bottom-right corners: (1,1), (1,2), (2,1), (2,2) → (3-1)*(3-1) = 4 possibilities
Total submatrices containing 5: 4×4 = 16 submatrices
Total contribution of element 5 to the sum: 5×16 = 80



// C++ program to find the sum of all possible submatrices
#include <iostream>
#include <vector>
using namespace std;
​
// Function to find the sum of all submatrices 
int matrixSum(vector<vector<int>>& matrix) {
    int n = matrix.size();
    int res = 0;
    
    // Iterate through each element in the matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            
            // Number of ways to choose the top-left corner 
            int topLeft = (i + 1) * (j + 1);
            
            // Number of ways to choose the bottom-right corner
            int bottomRight = (n - i) * (n - j);
            
            // Calculate contribution of current element
            res += (topLeft * bottomRight * matrix[i][j]);
        }
    }
    
    return res;
}
​
int main() {
    vector<vector<int>> matrix = {
        {1, 1},
        {1, 1}
    };
    
    cout << matrixSum(matrix);
    return 0;
}

Output
16


14.  Search a 2D Matrix II:
-----------------------------
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

example 1:
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true

example 2:
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false

class Solution {
public:
/*
    bool check(vector<vector<int>>& matrix, int row, int n, int target) {
        int low = 0;
        int high = n-1;
        
        while (low <= high) {
            int mid = (low + high) / 2;
            if (matrix[row][mid] == target) {
                return true;
            }

            if (matrix[row][mid] > target) {
                high = mid-1;
            } else {
                low = mid+1;
            }
        }

        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();

        for (int i=0; i<m; i++) {
            if (target >= matrix[i][0] && target <= matrix[i][n-1]) {
                if (check(matrix, i, n, target)) {
                    return true;
                }
            }
        }

        return false;
    }
    */
//INTERVIEWER'S LOVE THIS top-right stratergy
/*
Start at the top-right cell.
If the current value is greater than the target, move left.
If less, move down.
Repeat until found or bounds exceeded.
*/
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int r=0;
        int c=n-1;

        while (r<m && c>=0) {
            if (matrix[r][c] == target) return true;
            if (matrix[r][c] > target)  {
                c--;
                //if (c==-1) {
                  //  c=n-1;
                   // r++;
                //}
            } else if (matrix[r][c] < target) {
                r++;
            }    
        }

        return false;
    }
};


15. Modify an array such that if 'arr[i]' is 'j' then arr[j] becomes i:
-----------------------------------------------------------------------
Given an array arr[] of size n, where all elements are distinct and fall within the range 0 to n-1. The task is to modify arr[] such that if arr[i] = j, then it gets transformed into arr[j] = i.

Examples: 

Input: arr[] = [1, 3, 0, 2]
Output: 2 0 3 1
Explanation: Since arr[0] = 1, update arr[1] to 0
Since arr[1] = 3, update arr[3] to 1
Since arr[2] = 0, update arr[0] to 2
Since arr[3] = 2, update arr[2] to 3

Input: arr[] = [2, 0, 1, 4, 5, 3]
Output: 1 2 0 5 3 4
Explanation: Since arr[0] = 2, update arr[2] to 0
Since arr[1] = 0, update arr[0] to 1
Since arr[2] = 1, update arr[1] to 2
Since arr[3] = 4, update arr[4] to 3
Since arr[4] = 5, update arr[5] to 4
Since arr[5] = 3, update arr[3] to 5

Input: arr[] = [3, 2, 1, 0]
Output: 3 2 1 0
Explanation: Since each element is already at its correct index, the array remains unchanged.

[Brute Force Approach] Using an Extra Array - O(n) Time and O(n) Space
The idea is to use an extra array to directly place each element at its correct index without modifying the input during traversal. By observing that each element arr[i] represents its future index, we create a newArr where newArr[arr[i]] = i. Finally, we copy newArr back to arr to complete the rearrangement efficiently.




// C++ Code to Rearrange Array Elements
// using an Extra Array 
#include <bits/stdc++.h>
using namespace std;
​
void rearrange(vector<int>& arr) {
​
    int n = arr.size();
    
    // Create an auxiliary array to
    // store new values
    vector<int> newArr(n);
​
    // Place each element at its correct index
    for (int i = 0; i < n; i++) {  
        newArr[arr[i]] = i;
    }
​
    // Copy modified values back to the 
    // original array
    for (int i = 0; i < n; i++) {  
        arr[i] = newArr[i];
    }
}
​
​
int main() {
​
    vector<int> arr = {2, 0, 1, 4, 5, 3};
​
    rearrange(arr); 
    
    for (int x : arr) {  
        cout << x << " ";
    }
    
    return 0;
}

Output
1 2 0 5 3 4 

[Expected Approach 2] Using Modulo - O(n) Time and O(1) Space
The idea is to store both the old and new values within the same array using modulo and multiplication. Each element is updated such that arr[arr[i] % n] accumulates the new position while preserving the original value. After processing, the new values are extracted by performing integer division with n. This ensures an in-place transformation without using extra space. 




// C++ Code to Rearrange Array Elements
// using modulo
#include <bits/stdc++.h>
using namespace std;
​
// Rearrange arr[] so that arr[j] 
// becomes i if arr[i] is j
void rearrange(vector<int>& arr) {
​
    int n = arr.size();
​
    // Store new values using modulo
    for (int i = 0; i < n; i++) {  
        arr[arr[i] % n] += i * n;
    }
​
    // Extract new values
    for (int i = 0; i < n; i++) {  
        arr[i] /= n;
    }
}
​
int main() {
​
    vector<int> arr = {2, 0, 1, 4, 5, 3};
​
    rearrange(arr); 
    
    for (int x : arr) {  
        cout << x << " ";
    }
​
    return 0;
}

Output
1 2 0 5 3 4 




16. Permutation in String
--------------------------
Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
In other words, return true if one of s1's permutations is the substring of s2.

Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:

Input: s1 = "ab", s2 = "eidboaoo"
Output: false
 
Constraints:

1 <= s1.length, s2.length <= 104
s1 and s2 consist of lowercase English letters.

bool checkInclusion(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        if (n1 > n2) return false;

        vector<int> ms1(26, 0);
        for (auto c:s1) ms1[c-'a']++;

        vector<int> ms2(26, 0);
        int i=0;
        int j=0;
        while (j<n2) {
            ms2[s2[j]-'a']++;
            if (j-i+1 == n1) {
                if (ms2 == ms1) return true;
            } 
            
            if (j-i+1 < n1) {
                j++;
            } else {
                ms2[s2[i]-'a']--;
                i++;
                j++;
            }
        }

        return false;
    }

17. Majority Element II:
-----------------------
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 
Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        if (n==1) return nums;
        
        int a = 0;
        int b = 0;
        int ac = 0;
        int bc = 0;
        for (auto i: nums) {
            if (a==i)  {
                ac++;
            } else if (b==i) {
                bc++;
            } else if (ac==0) {
                a=i;
                ac++;
            } else if (bc==0) {
                b=i;
                bc++;
            } else {
                ac--;
                bc--;
            }
        }

        vector<int> ans;
        ac = 0;
        bc = 0;
        for (auto k: nums) {
            if (k==a) ac++;
            else if (k==b) bc++;
        }
        if (ac > (n/3)) ans.push_back(a);
        if (bc > (n/3)) ans.push_back(b);

        return ans;
    }
};
 

28. 8. String to Integer (atoi)
Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.

The algorithm for myAtoi(string s) is as follows:

Whitespace: Ignore any leading whitespace (" ").
Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present.
Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.
Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.
Return the integer as the final result.

 
Example 1:
Input: s = "42"
Output: 42
Explanation:
The underlined characters are what is read in and the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)
           ^

Example 2:
Input: s = " -042"
Output: -42
Explanation:
Step 1: "   -042" (leading whitespace is read and ignored)
            ^
Step 2: "   -042" ('-' is read, so the result should be negative)
             ^
Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)
               ^

Example 3:
Input: s = "1337c0d3"
Output: 1337
Explanation:
Step 1: "1337c0d3" (no characters read because there is no leading whitespace)
         ^
Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)
             ^

Example 4:
Input: s = "0-1"
Output: 0
Explanation:
Step 1: "0-1" (no characters read because there is no leading whitespace)
         ^
Step 2: "0-1" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)
          ^

Example 5:
Input: s = "words and 987"
Output: 0

Explanation:
Reading stops at the first non-digit character 'w'.

Constraints:
0 <= s.length <= 200
s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.

class Solution {
public:
    int myAtoi(string s) {
        int n = s.size();
        int i=0;
        while (i<n && s[i] == ' ') i++;
        long long ans = 0;
        bool neg = false;
        if (s[i] == '-') {
            neg = true;
            i++;
        } else if (s[i] == '+') i++;
        if (!(s[i] >= '0' &&  s[i] <= '9')) return 0;
        while (i<n && s[i] == '0') i++;
        while (i<n) {
            if (s[i] >= '0' &&  s[i] <= '9') {
                ans += s[i]-'0';
                i++;
                if (i<n && (s[i] >= '0' &&  s[i] <= '9')) {
                    if (i<n && ans > (INT_MAX/10)) {
                        if (neg) return INT_MIN;
                        else return INT_MAX;
                    } 
                    ans *= 10;
                }
            } else {
                break;
            }
        }
        if (neg) {
            ans *= -1;
        }
        if (ans < INT_MIN) return INT_MIN;
        if (ans > INT_MAX) return INT_MAX;
        return ans;
    }
};


1. Reverse String:
------------------
Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.

Example 1:
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
Example 2:
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
 
Constraints:
1 <= s.length <= 105
s[i] is a printable ascii character.

class Solution {
public:
    void revrs(vector<char>& s, int i, int j) {
        if (i > j) return;

        swap(s[i], s[j]);
        revrs(s, i+1, j-1);
    }

    void reverseString(vector<char>& s) {
        revrs(s, 0, s.size()-1);
    }
};


2. Fibonacci Number:
----------------------
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

Example 1:
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

Example 2:
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

Example 3:
Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
 
Constraints:
0 <= n <= 30

class Solution {
public:
    int fib(int n) {
        if (n==0 || n==1) return n;

        return fib(n-1) + fib(n-2);
    }
};



4. Power of Two:
----------------
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2x.

Example 1:
Input: n = 1
Output: true
Explanation: 20 = 1

Example 2:
Input: n = 16
Output: true
Explanation: 24 = 16

Example 3:
Input: n = 3
Output: false
 

Constraints:
-231 <= n <= 231 - 1

class Solution {
public:
    bool isPowerOfTwo(int n) {
        //return n>0 && (n & (n-1))  == 0; //n == 4 100 n-1 = 3 011 4 & 3 = 0 similarly for all n which arepower of 2 & with n-1 will give 0.  10--1010 9--1001 10 & 9 = 8 (1000) not 0 so not pow of 2
        if (n==1) return true;
        if (n%2 != 0) return false;
        if (n<=0) return false;
        return isPowerOfTwo(n/2);
    }
};

5. Print N to 1 without loop:
--------------------------------
Print numbers from N to 1 (space separated) without the help of loops.

Example 1:
Input:
N = 10
Output: 10 9 8 7 6 5 4 3 2 1
Your Task:
This is a function problem. You only need to complete the function printNos() that takes N as parameter and prints number from N to 1 recursively. Don't print newline, it will be added by the driver code.

Expected Time Complexity: O(N).
Expected Auxiliary Space: O(N) (Recursive).

Constraint
1<=n<=1000

class Solution {
  public:
    void printNos(int N) {
        // code here
        if (N==1) {
            cout <<N;
            return;
        }
        
        cout<<N<<" ";
        printNos(N-1);
    }
};


6. Pow(x, n):
-------------
Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

Example 1:
Input: x = 2.00000, n = 10
Output: 1024.00000

Example 2:
Input: x = 2.10000, n = 3
Output: 9.26100

Example 3:
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
 

Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104

Approach
We will recursively call the Pow function until it boils down to n==1 or n==-1
In case of n as negative we need to divide x by itself so in the case when n is -1 we will return 1/x and for n==1 we will return x
In order to further make it more efficient we will further divide n by 2 to make it efficient. Why this works, check below.
we can write 2 pow 10 as (2 pow 5) * (2 pow 5)
2^10 = 1024
2^10 = 2^5 * 2^5 (32 * 32= 1024)
Now, we can further write 2^5 as 2 * 2^2 * 2^2
ans, 2^2 as 2^1 * 2^1
Now in the recursion when n==1 we hit the base case return x
So in recursive call we will solve for n/2 and get the result
--if n is even return res*res
--if n is odd return x * res * res for (n>0) else 1/x * res * res if n is negative

class Solution {
public:
    double Pow(double x, int n, bool neg) {
        if (n==1) return x;
        if (n==-1) return 1/x;
        double res = Pow(x, n/2, neg);
        return (n%2 == 0) ?  res*res : ((neg == true) ? 1/x * res*res : x *res * res);
    }

    double myPow(double x, int n) {
        if (n==0) return 1;
        if (n==1) return x;
        if (n==-1) return 1/x;
        bool neg  = false;
        if (n < 0) neg = true;
        if (neg == false && x == 1.00000) {
            return x;
        }
        
        double res = Pow(x, n/2, neg);
        return (n%2 == 0) ?  res*res : ((neg == true) ? 1/x * res*res : x *res * res);
    }
};


8. Combinations:
----------------
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].
You may return the answer in any order.

Example 1:
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

Example 2:
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 
Constraints:
1 <= n <= 20
1 <= k <= n

class Solution {
public:
    void comb(int i, int n, int k , vector<int> &arr, vector<vector<int>> &res) {
        if (arr.size() == k) {
            res.push_back(arr);
            return;
        }
        
        for (;i<=n; i++) {
            arr.push_back(i);
            comb(i+1, n, k, arr, res);
            arr.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> arr;
        comb(1, n, k, arr, res);
        return res;
    }
};


9. Combination Sum III:
-----------------------
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.

Example 2:
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.

Example 3:
Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.
 
Constraints:
2 <= k <= 9
1 <= n <= 60

class Solution {
public:
    void combSum(int i, int k, int n, vector<int> &arr, vector<vector<int>> &res) {
        if (arr.size() == k && n==0) {
            res.push_back(arr);
            return;
        }

        for (; i<=9; i++) {
            arr.push_back(i);
            combSum(i+1, k, n-i, arr, res);
            arr.pop_back();
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> arr;
        combSum(1, k, n, arr, res);
        return res;
    }
};

10. Power Set:
--------------
Given a string s of length n, find all the possible non-empty subsequences of the string s in lexicographically-sorted order.

Example 1:
Input : 
s = "abc"
Output: 
a ab abc ac b bc c
Explanation : 
There are a total 7 number of subsequences possible for the given string, and they are mentioned above in lexicographically sorted order.

Example 2:
Input: 
s = "aa"
Output: 
a a aa
Explanation : 
There are a total 3 number of subsequences possible for the given string, and they are mentioned above in lexicographically sorted order.
Your Task:
You don't need to read input or print anything. Your task is to complete the function AllPossibleStrings() which takes a string s as the input parameter and returns a list of all possible subsequences (non-empty) that can be formed from s in lexicographically sorted order.

Expected Time Complexity: O( n*2n  )
Expected Space Complexity: O( n * 2n )

Constraints: 
1 <= n <= 16
s constitutes of lower case english alphabets

Company Tags:Snapdeal

class Solution {
  public:
    void lexo(int i, int n, string &sub, string s, vector<string> &res) {
        if (sub.size() == n) {
            //res.push_back(sub);
            return;
        }
        
        for (; i<n; i++) {
            sub.push_back(s[i]);
            res.push_back(sub);
            lexo(i+1, n, sub, s, res);
            sub.pop_back();
        }
    }
    
    vector<string> AllPossibleStrings(string s) {
        // Code here
        vector<string> res;
        string sub = "";
        int n = s.size();
        lexo(0, n, sub, s, res);
        sort(res.begin(), res.end());
        return res;
    }
};


11. Combination Sum:
--------------------
Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:
Input: candidates = [2], target = 1
Output: []
 

Constraints:

1 <= candidates.length <= 30
2 <= candidates[i] <= 40
All elements of candidates are distinct.
1 <= target <= 40

class Solution {
public:
    void combSum(int i, int n, int t, vector<int>& candidates, vector<int> &arr, set<vector<int>> &res) {
        if (t == 0) {
            res.insert(arr);
            return;
        }

        if(t<0) return;

        if (i>=n) return;
        
        arr.push_back(candidates[i]);
        combSum(i, n, t-candidates[i], candidates, arr, res);
        combSum(i+1, n, t-candidates[i], candidates, arr, res);
        if (arr.size()) arr.pop_back();
        combSum(i+1, n, t, candidates, arr, res);
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        set<vector<int>> res;
        vector<int> arr;
        int n= candidates.size();
        combSum(0, n, target, candidates, arr, res);
        vector<vector<int>> ans;
        for (auto i : res) {
            ans.push_back(i);
        }
        return ans;
    }
};


17. Bracket Challenge:
------------------------
Vivek has taught the question on printing all the valid balanced parentheses sequences given N pairs of parentheses in the webinar on recursion.
He wants to test his students, so, he asks them a similar related question. He asks them to print all the valid balanced bracket sequence given N pairs of parantheses () and M pairs of braces {}.

Can you solve this variation of his problem?

Remember a balanced parentheses has following properties:
For any type of bracket (parentheses/brace), the number of opening and closing brackets should be equal. The following are invalid: (){}} ({({})}
For any type of bracket, and any index of the string, the number of opening bracket before that index should be greater or equal to the number of closing brackets. The following are invalid: ()}{ ({}))(
For any two matching pairs of different types of brackets, it should not happen that one type of bracket has opening before the opening of other bracket but has closing after the second type of closing. This is invalid: {(}) but these are valid: {()} ({}).
Input Format

The first line of input consists of two integers, N and M, which denote the number of parentheses and the number of braces pair.

Constraints   
1 <= N + M <= 10

Output Format
Output all the valid balanced bracket sequences for given number of parantheses and braces pairs, one in each newline.

Sample Input 0
1 2

Sample Output 0

(){}{}
{}(){}
{}{}()
(){{}}
{{}}()
{}{()}
{}({})
{()}{}
({}){}
(){{}}
{{}}()
{{()}}
{({})}
({{}})
({}{})
{(){}}
{{}()}


#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;

void validpr(int leftn, int rightn, int leftm, int rightm, int n, int m, vector<string> &res, string &curr, stack<char> &st) {
    if (leftn==n && rightn==n && leftm==m && rightm==m) {
        if (curr.size() > 0) res.push_back(curr);
        return;
    }
    
    if (leftn < n) {
        curr.push_back('(');
        st.push('(');
        validpr(leftn+1, rightn, leftm, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.pop();
    }
    
    if (leftm < m) {
        curr.push_back('{');
        st.push('{');
        validpr(leftn, rightn, leftm+1, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.pop();
    }
    
    if (rightn < n && leftn > rightn && !st.empty() && st.top() == '(') {
        char ch = st.top(); //last bracket was open so remove the last open bracket and see if any other string we can get
        st.pop();
        curr.push_back(')');
        validpr(leftn, rightn+1, leftm, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.push(ch); //restore back prev state of stack
    }
    
    
    if (rightm < m && leftm > rightm && !st.empty() && st.top() == '{') {
        char ch = st.top();
        st.pop();
        curr.push_back('}');
        validpr(leftn, rightn, leftm, rightm+1, n, m, res, curr, st);
        curr.pop_back();
        st.push(ch);
    }
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n;
    int m;
    cin>>n>>m;
    vector<string> res;
    string curr ="";
    stack<char> st;
    validpr(0, 0, 0, 0, n, m, res, curr, st);
    
    for (const string& s : res) {
        cout << s << endl;
    }
    return 0;
}


18.Non-Crossing Handshakes (Catalan Problem) â€” Short Notes
ðŸ”¹ Problem

N people (N must be even) stand in a circle

Each person shakes hands exactly once

No two handshakes cross

Find number of possible handshake arrangements

ðŸ”¹ Key Rules

Each handshake uses 2 people

Odd N â‡’ 0 ways

Handshakes are chords inside a circle

Chords must not intersect

ðŸ”¹ Core Idea

Fix person 1

Person 1 can shake with:

2, 4, 6, ..., N


That handshake splits the circle into:

Left group

Right group

Both groups are independent

Count ways recursively

ðŸ”¹ Recurrence Relation

Let f(n) = number of valid arrangements

f(0) = 1
f(2) = 1
f(n) = Î£ f(i - 2) Ã— f(n - i)
        for i = 2, 4, ..., n

ðŸ”¹ Example (n = 6)
f(6) = f(0)*f(4) + f(2)*f(2) + f(4)*f(0)
     = 1*2 + 1*1 + 2*1
     = 5

ðŸ”¹ Why Multiplication?

Left and right sides are independent

Total ways = left Ã— right

ðŸ”¹ Why Addition?

Each partner choice is a different case

Sum all valid cases

ðŸ”¹ Relation to Catalan Numbers

If N = 2k:

Answer = Catalan(k)


Same problem as:

Balanced parentheses

BST counting

Polygon triangulation

ðŸ”¹ Recursive Code (Core Logic)
long long handshake(int n) {
    if (n == 0 || n == 2) return 1;
    if (n % 2 == 1) return 0;

    long long ways = 0;
    for (int i = 2; i <= n; i += 2) {
        ways += handshake(i - 2) * handshake(n - i);
    }
    return ways;
}

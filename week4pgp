1. Reverse String:
------------------
Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.

Example 1:
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
Example 2:
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
 
Constraints:
1 <= s.length <= 105
s[i] is a printable ascii character.

class Solution {
public:
    void revrs(vector<char>& s, int i, int j) {
        if (i > j) return;

        swap(s[i], s[j]);
        revrs(s, i+1, j-1);
    }

    void reverseString(vector<char>& s) {
        revrs(s, 0, s.size()-1);
    }
};


2. Fibonacci Number:
----------------------
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

Example 1:
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

Example 2:
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

Example 3:
Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
 
Constraints:
0 <= n <= 30

class Solution {
public:
    int fib(int n) {
        if (n==0 || n==1) return n;

        return fib(n-1) + fib(n-2);
    }
};



4. Power of Two:
----------------
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2x.

Example 1:
Input: n = 1
Output: true
Explanation: 20 = 1

Example 2:
Input: n = 16
Output: true
Explanation: 24 = 16

Example 3:
Input: n = 3
Output: false
 

Constraints:
-231 <= n <= 231 - 1

class Solution {
public:
    bool isPowerOfTwo(int n) {
        //return n>0 && (n & (n-1))  == 0; //n == 4 100 n-1 = 3 011 4 & 3 = 0 similarly for all n which arepower of 2 & with n-1 will give 0.  10--1010 9--1001 10 & 9 = 8 (1000) not 0 so not pow of 2
        if (n==1) return true;
        if (n%2 != 0) return false;
        if (n<=0) return false;
        return isPowerOfTwo(n/2);
    }
};

5. Print N to 1 without loop:
--------------------------------
Print numbers from N to 1 (space separated) without the help of loops.

Example 1:
Input:
N = 10
Output: 10 9 8 7 6 5 4 3 2 1
Your Task:
This is a function problem. You only need to complete the function printNos() that takes N as parameter and prints number from N to 1 recursively. Don't print newline, it will be added by the driver code.

Expected Time Complexity: O(N).
Expected Auxiliary Space: O(N) (Recursive).

Constraint
1<=n<=1000

class Solution {
  public:
    void printNos(int N) {
        // code here
        if (N==1) {
            cout <<N;
            return;
        }
        
        cout<<N<<" ";
        printNos(N-1);
    }
};


6. Pow(x, n):
-------------
Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

Example 1:
Input: x = 2.00000, n = 10
Output: 1024.00000

Example 2:
Input: x = 2.10000, n = 3
Output: 9.26100

Example 3:
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
 

Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104

Approach
We will recursively call the Pow function until it boils down to n==1 or n==-1
In case of n as negative we need to divide x by itself so in the case when n is -1 we will return 1/x and for n==1 we will return x
In order to further make it more efficient we will further divide n by 2 to make it efficient. Why this works, check below.
we can write 2 pow 10 as (2 pow 5) * (2 pow 5)
2^10 = 1024
2^10 = 2^5 * 2^5 (32 * 32= 1024)
Now, we can further write 2^5 as 2 * 2^2 * 2^2
ans, 2^2 as 2^1 * 2^1
Now in the recursion when n==1 we hit the base case return x
So in recursive call we will solve for n/2 and get the result
--if n is even return res*res
--if n is odd return x * res * res for (n>0) else 1/x * res * res if n is negative

class Solution {
public:
    double Pow(double x, int n, bool neg) {
        if (n==1) return x;
        if (n==-1) return 1/x;
        double res = Pow(x, n/2, neg);
        return (n%2 == 0) ?  res*res : ((neg == true) ? 1/x * res*res : x *res * res);
    }

    double myPow(double x, int n) {
        if (n==0) return 1;
        if (n==1) return x;
        if (n==-1) return 1/x;
        bool neg  = false;
        if (n < 0) neg = true;
        if (neg == false && x == 1.00000) {
            return x;
        }
        
        double res = Pow(x, n/2, neg);
        return (n%2 == 0) ?  res*res : ((neg == true) ? 1/x * res*res : x *res * res);
    }
};


8. Combinations:
----------------
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].
You may return the answer in any order.

Example 1:
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

Example 2:
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 
Constraints:
1 <= n <= 20
1 <= k <= n

class Solution {
public:
    void comb(int i, int n, int k , vector<int> &arr, vector<vector<int>> &res) {
        if (arr.size() == k) {
            res.push_back(arr);
            return;
        }
        
        for (;i<=n; i++) {
            arr.push_back(i);
            comb(i+1, n, k, arr, res);
            arr.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> arr;
        comb(1, n, k, arr, res);
        return res;
    }
};


9. Combination Sum III:
-----------------------
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.

Example 2:
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.

Example 3:
Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.
 
Constraints:
2 <= k <= 9
1 <= n <= 60

class Solution {
public:
    void combSum(int i, int k, int n, vector<int> &arr, vector<vector<int>> &res) {
        if (arr.size() == k && n==0) {
            res.push_back(arr);
            return;
        }

        for (; i<=9; i++) {
            arr.push_back(i);
            combSum(i+1, k, n-i, arr, res);
            arr.pop_back();
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> arr;
        combSum(1, k, n, arr, res);
        return res;
    }
};

10. Power Set:
--------------
Given a string s of length n, find all the possible non-empty subsequences of the string s in lexicographically-sorted order.

Example 1:
Input : 
s = "abc"
Output: 
a ab abc ac b bc c
Explanation : 
There are a total 7 number of subsequences possible for the given string, and they are mentioned above in lexicographically sorted order.

Example 2:
Input: 
s = "aa"
Output: 
a a aa
Explanation : 
There are a total 3 number of subsequences possible for the given string, and they are mentioned above in lexicographically sorted order.
Your Task:
You don't need to read input or print anything. Your task is to complete the function AllPossibleStrings() which takes a string s as the input parameter and returns a list of all possible subsequences (non-empty) that can be formed from s in lexicographically sorted order.

Expected Time Complexity: O( n*2n  )
Expected Space Complexity: O( n * 2n )

Constraints: 
1 <= n <= 16
s constitutes of lower case english alphabets

Company Tags:Snapdeal

class Solution {
  public:
    void lexo(int i, int n, string &sub, string s, vector<string> &res) {
        if (sub.size() == n) {
            //res.push_back(sub);
            return;
        }
        
        for (; i<n; i++) {
            sub.push_back(s[i]);
            res.push_back(sub);
            lexo(i+1, n, sub, s, res);
            sub.pop_back();
        }
    }
    
    vector<string> AllPossibleStrings(string s) {
        // Code here
        vector<string> res;
        string sub = "";
        int n = s.size();
        lexo(0, n, sub, s, res);
        sort(res.begin(), res.end());
        return res;
    }
};


11. Combination Sum:
--------------------
Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:
Input: candidates = [2], target = 1
Output: []
 

Constraints:

1 <= candidates.length <= 30
2 <= candidates[i] <= 40
All elements of candidates are distinct.
1 <= target <= 40

class Solution {
public:
    void combSum(int i, int n, int t, vector<int>& candidates, vector<int> &arr, set<vector<int>> &res) {
        if (t == 0) {
            res.insert(arr);
            return;
        }

        if(t<0) return;

        if (i>=n) return;
        
        arr.push_back(candidates[i]);
        combSum(i, n, t-candidates[i], candidates, arr, res);
        combSum(i+1, n, t-candidates[i], candidates, arr, res);
        if (arr.size()) arr.pop_back();
        combSum(i+1, n, t, candidates, arr, res);
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        set<vector<int>> res;
        vector<int> arr;
        int n= candidates.size();
        combSum(0, n, target, candidates, arr, res);
        vector<vector<int>> ans;
        for (auto i : res) {
            ans.push_back(i);
        }
        return ans;
    }
};


13.  Predict the Winner:
-------------------------
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.
Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.

Example 1:
Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.

Example 2:
Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
 
Constraints:
1 <= nums.length <= 20
0 <= nums[i] <= 107

(if you choose a no i then you will either win/loose by nums[i] - f(i+1, j)(other player can choose from this))
(13-1-26 2hrs medium lvl)
/*
     int calc(int i, int j, vector<int>& nums) {
        if (i == j) {
            return nums[i];
        }

        int left = nums[i] - calc(i+1, j, nums);
        int right = nums[j] - calc(i, j-1, nums);
        return max(left, right);
    }
*/

    int calc(int i, int j, vector<int>& nums, vector<vector<int>> &dp) {
        if (i == j) {
            return nums[i]; //if only one num left return it
        }

        if (dp[i][j]!= 0) {
            return dp[i][j];
        }

        int left = nums[i] - calc(i+1, j, nums, dp);//u pick i then  other playe can pick from nums[i+1:j] so you will either win/loose by nums[i] - (f(i+1, j))
        int right = nums[j] - calc(i, j-1, nums, dp);//u pick j then  other playe can pick from nums[i:j-1] so you will either win/loose by nums[j] - f(i, j-1)
        return dp[i][j] = max(left, right);
    }

    bool predictTheWinner(vector<int>& nums) {
        int n = nums.size();
       // return calc(0, n-1, nums) >= 0;
       vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
       return calc(0, n-1, nums, dp)>=0; //if val -ve u loose by the other player by - points else win or tie
    }


14. Count Good Numbers:
------------------------
A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).

For example, "2582" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, "3245" is not good because 3 is at an even index but is not even.
Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.

A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.

Example 1:
Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".

Example 2:
Input: n = 4
Output: 400

Example 3:
Input: n = 50
Output: 564908303
 
Constraints:
1 <= n <= 1015

int mod = 1e9 + 7;

    long long comp(long long num, long long i) {
        if (i==0) return 1;

        long long val = comp(num, i/2);
        return (i%2==0) ? (val%mod) * (val%mod) : num * (val%mod) * (val%mod);
    }

    int countGoodNumbers(long long n) {
        long long count = 1;
       
       // countGood(0, n, count);
    //    for (long long i=0; i<n; i++) {
    //     if (i%2==0) {
    //         count = ((count % mod) * 5)%mod;
    //     } else {
    //         count =  ((count % mod) * 4)% mod;
    //     }
    //    }

        long long ce = 0;
        long long co = 0;
       
        ce = (n+1) / 2;
        co = n/2;
        long long countevn = comp(5, ce/2);
        long long totevn = (ce % 2 == 0) ? (countevn % mod) * (countevn % mod) : 5 * (countevn % mod) * (countevn % mod);
        
        long long countodd = comp(4, co/2);
        long long totodd = (co % 2 == 0) ? (countodd % mod) * (countodd % mod) : 4 * (countodd % mod) * (countodd % mod);

        count = ((totevn % mod) * (totodd % mod)) % mod;
        return count;
    }




15. Word Break:
----------------
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

Example 1:
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

Example 2:
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.

Example 3:
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
 
Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.

bool check(int i, string s, vector<string>&mp, vector<int>& dp) {
        if (s.size() == i) return true;
        if (dp[i] != -1) return dp[i];

        for (auto j: mp) {
            int ln = j.size();
            if (i+ln <= s.size() && s.substr(i, ln) == j) {
                if (check(i+ln, s, mp, dp)) {
                    dp[i]= 1;
                    return true;
                }
            }
        }

        return dp[i]=false;
    }

    bool wordBreak(string s, vector<string>& wordDict) {
        string curr = "";
        vector<int> dp(s.size()+1, -1);
        return check(0, s, wordDict, dp);
    }


17. Bracket Challenge:
------------------------
Vivek has taught the question on printing all the valid balanced parentheses sequences given N pairs of parentheses in the webinar on recursion.
He wants to test his students, so, he asks them a similar related question. He asks them to print all the valid balanced bracket sequence given N pairs of parantheses () and M pairs of braces {}.

Can you solve this variation of his problem?

Remember a balanced parentheses has following properties:
For any type of bracket (parentheses/brace), the number of opening and closing brackets should be equal. The following are invalid: (){}} ({({})}
For any type of bracket, and any index of the string, the number of opening bracket before that index should be greater or equal to the number of closing brackets. The following are invalid: ()}{ ({}))(
For any two matching pairs of different types of brackets, it should not happen that one type of bracket has opening before the opening of other bracket but has closing after the second type of closing. This is invalid: {(}) but these are valid: {()} ({}).
Input Format

The first line of input consists of two integers, N and M, which denote the number of parentheses and the number of braces pair.

Constraints   
1 <= N + M <= 10

Output Format
Output all the valid balanced bracket sequences for given number of parantheses and braces pairs, one in each newline.

Sample Input 0
1 2

Sample Output 0

(){}{}
{}(){}
{}{}()
(){{}}
{{}}()
{}{()}
{}({})
{()}{}
({}){}
(){{}}
{{}}()
{{()}}
{({})}
({{}})
({}{})
{(){}}
{{}()}


#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;

void validpr(int leftn, int rightn, int leftm, int rightm, int n, int m, vector<string> &res, string &curr, stack<char> &st) {
    if (leftn==n && rightn==n && leftm==m && rightm==m) {
        if (curr.size() > 0) res.push_back(curr);
        return;
    }
    
    if (leftn < n) {
        curr.push_back('(');
        st.push('(');
        validpr(leftn+1, rightn, leftm, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.pop();
    }
    
    if (leftm < m) {
        curr.push_back('{');
        st.push('{');
        validpr(leftn, rightn, leftm+1, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.pop();
    }
    
    if (rightn < n && leftn > rightn && !st.empty() && st.top() == '(') {
        char ch = st.top(); //last bracket was open so remove the last open bracket and see if any other string we can get
        st.pop();
        curr.push_back(')');
        validpr(leftn, rightn+1, leftm, rightm, n, m, res, curr, st);
        curr.pop_back();
        st.push(ch); //restore back prev state of stack
    }
    
    
    if (rightm < m && leftm > rightm && !st.empty() && st.top() == '{') {
        char ch = st.top();
        st.pop();
        curr.push_back('}');
        validpr(leftn, rightn, leftm, rightm+1, n, m, res, curr, st);
        curr.pop_back();
        st.push(ch);
    }
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int n;
    int m;
    cin>>n>>m;
    vector<string> res;
    string curr ="";
    stack<char> st;
    validpr(0, 0, 0, 0, n, m, res, curr, st);
    
    for (const string& s : res) {
        cout << s << endl;
    }
    return 0;
}


14. Count Good Numbers:
------------------------
A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).

For example, "2582" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, "3245" is not good because 3 is at an even index but is not even.
Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.

A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.

Example 1:
Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".

Example 2:
Input: n = 4
Output: 400

Example 3:
Input: n = 50
Output: 564908303
 
Constraints:
1 <= n <= 1015

int mod = 1e9 + 7;

    long long comp(long long num, long long i) {
        if (i==0) return 1;

        long long val = comp(num, i/2);
        return (i%2==0) ? (val%mod) * (val%mod) : num * (val%mod) * (val%mod);
    }

    int countGoodNumbers(long long n) {
        long long count = 1;
       
       // countGood(0, n, count);
    //    for (long long i=0; i<n; i++) {
    //     if (i%2==0) {
    //         count = ((count % mod) * 5)%mod;
    //     } else {
    //         count =  ((count % mod) * 4)% mod;
    //     }
    //    }

        long long ce = 0;
        long long co = 0;
        
        ce = (n+1) / 2;
        co = n/2;
        long long countevn = comp(5, ce/2);
        long long totevn = (ce % 2 == 0) ? (countevn % mod) * (countevn % mod) : 5 * (countevn % mod) * (countevn % mod);
        
        long long countodd = comp(4, co/2);
        long long totodd = (co % 2 == 0) ? (countodd % mod) * (countodd % mod) : 4 * (countodd % mod) * (countodd % mod);

        count = ((totevn % mod) * (totodd % mod)) % mod;
        return count;
    }


16. Subsets II:
------------------
Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.

Example 1:
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]

Example 2:
Input: nums = [0]
Output: [[],[0]]
 
Constraints:
1 <= nums.length <= 10
-10 <= nums[i] <= 10

   void subset(set<vector<int>> &res, int i, vector<int> &curr, vector<int>& nums) {
        if (i == nums.size()){
            res.insert(curr);
            return;
        } 

        subset(res, i+1, curr, nums);
        curr.push_back(nums[i]);
        subset(res, i+1, curr, nums);
        curr.pop_back();
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        set<vector<int>> res;
        vector<int> curr;
        sort(nums.begin(), nums.end());
        subset(res, 0, curr, nums);
        vector<vector<int>> fin(res.begin(), res.end());
        
       // sort(fin.begin(), fin.end());
        return fin;
    }
/*
//beats 100%
    vector<vector<int>> ans;
    vector<int> path;

    void dfs(int idx, vector<int>& nums) {
        ans.push_back(path);

        for (int i = idx; i < nums.size(); i++) {
            // skip duplicates
            if (i > idx && nums[i] == nums[i - 1]) continue;

            path.push_back(nums[i]);
            dfs(i + 1, nums);
            path.pop_back();
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        dfs(0, nums);
        return ans;
    }
    */



17. Bracket Challenge:
-----------------------
Vivek has taught the question on printing all the valid balanced parentheses sequences given N pairs of parentheses in the webinar on recursion.

He wants to test his students, so, he asks them a similar related question. He asks them to print all the valid balanced bracket sequence given N pairs of parantheses () and M pairs of braces {}.

Can you solve this variation of his problem?

Remember a balanced parentheses has following properties:

For any type of bracket (parentheses/brace), the number of opening and closing brackets should be equal. The following are invalid: (){}} ({({})}
For any type of bracket, and any index of the string, the number of opening bracket before that index should be greater or equal to the number of closing brackets. The following are invalid: ()}{ ({}))(
For any two matching pairs of different types of brackets, it should not happen that one type of bracket has opening before the opening of other bracket but has closing after the second type of closing. This is invalid: {(}) but these are valid: {()} ({}).
Input Format

The first line of input consists of two integers, N and M, which denote the number of parentheses and the number of braces pair.

Constraints

1 <= N + M <= 10

Output Format

Output all the valid balanced bracket sequences for given number of parantheses and braces pairs, one in each newline.

Sample Input 0

1 2
Sample Output 0

(){}{}
{}(){}
{}{}()
(){{}}
{{}}()
{}{()}
{}({})
{()}{}
({}){}
(){{}}
{{}}()
{{()}}
{({})}
({{}})
({}{})
{(){}}
{{}()}


#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;

//st stack stores the open braces/paranthesis only, this is to prevent any false closing if open brace/paranthesis present at top of stack matches to the close brace/paranthesis we are trying to close only then close brac/paranthesis
void balanced(int open_n, int close_n, int open_m, int close_m, vector<string> &res, string &curr, stack<char> &st) {
    if (open_n == 0 && close_n == 0 && 0 == open_m && 0 == close_m) {
        res.push_back(curr);
        return;
    }
    
    if (open_n > 0) {
        st.push('(');
        curr.push_back('(');
        balanced(open_n-1, close_n, open_m, close_m, res, curr, st);
        st.pop();
        curr.pop_back();
    }
    
    if (close_n >0 && close_n > open_n && st.top() == '(') {
        st.pop();  //as top has '(' and we are going to close it pop the '(' else it will cause inconsistency
        curr.push_back(')');
        balanced(open_n, close_n-1, open_m, close_m, res, curr, st);
        st.push('('); //push back '(' to stack as we will try other options
        curr.pop_back();
    }
    
    if (open_m > 0) {
        st.push('{');
        curr.push_back('{');
        balanced(open_n, close_n, open_m-1, close_m, res, curr, st);
        st.pop();
        curr.pop_back();
    }
    
    if (close_m >0 && close_m > open_m && st.top() == '{') {
        st.pop(); as top has '{' and we are going to close '}' it pop the '{' else it will cause inconsistency
        curr.push_back('}');
        balanced(open_n, close_n, open_m, close_m-1, res, curr, st);
        st.push('{'); //push back '{' to stack as we will try other options
        curr.pop_back();
    }
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n;
    int m;
    cin>>n>>m;
    vector<string> res;
    string curr ="";
    stack<char> st;
    balanced(n, n, m, m, res, curr, st);
    for (auto s: res) {
        cout<<s<<endl;
    }
    return 0;
}


18.Non-Crossing Handshakes (Catalan Problem) â€” Short Notes
ðŸ”¹ Problem

N people (N must be even) stand in a circle

Each person shakes hands exactly once

No two handshakes cross

Find number of possible handshake arrangements

ðŸ”¹ Key Rules

Each handshake uses 2 people

Odd N â‡’ 0 ways

Handshakes are chords inside a circle

Chords must not intersect

ðŸ”¹ Core Idea

Fix person 1

Person 1 can shake with:

2, 4, 6, ..., N


That handshake splits the circle into:

Left group

Right group

Both groups are independent

Count ways recursively

ðŸ”¹ Recurrence Relation

Let f(n) = number of valid arrangements

f(0) = 1
f(2) = 1
f(n) = Î£ f(i - 2) Ã— f(n - i)
        for i = 2, 4, ..., n

ðŸ”¹ Example (n = 6)
f(6) = f(0)*f(4) + f(2)*f(2) + f(4)*f(0)
     = 1*2 + 1*1 + 2*1
     = 5

ðŸ”¹ Why Multiplication?

Left and right sides are independent

Total ways = left Ã— right

ðŸ”¹ Why Addition?

Each partner choice is a different case

Sum all valid cases

ðŸ”¹ Relation to Catalan Numbers

If N = 2k:

Answer = Catalan(k)


Same problem as:

Balanced parentheses

BST counting

Polygon triangulation

ðŸ”¹ Recursive Code (Core Logic)
long long handshake(int n) {
    if (n == 0 || n == 2) return 1;
    if (n % 2 == 1) return 0;

    long long ways = 0;
    for (int i = 2; i <= n; i += 2) {
        ways += handshake(i - 2) * handshake(n - i);
    }
    return ways;
}


need to solve

19. Rat Maze With Multiple Jumps:
------------------------------------
A maze is given as n*n matrix of blocks where source block is the upper left most block i.e., matrix[0][0] and destination block is lower rightmost block i.e., matrix[n-1][n-1]. A rat starts from source and has to reach the destination.

The rat can move in only two directions: first forward (if possible) or down.
In the maze matrix, 0 means the block is the dead end and non-zero number means the block can be used in the path from source to destination. The non-zero value of mat[i][j] indicates number of maximum jumps rat can make from cell mat[i][j]. 
Return a maxtrix of size n*n in which 1 at (i, j) represents the cell is taken into the path otherwise 0 .

Note : If multiple solutions exist, the shortest earliest hop will be accepted. For the same hop distance at any point, forward will be preferred over downward. 

Example:
Input: {{2,1,0,0},{3,0,0,1},{0,1,0,1},
{0,0,0,1}}
Output: {{1,0,0,0},{1,0,0,1},{0,0,0,1},
{0,0,0,1}}
Explanation: Rat started with matrix[0][0] and 
can jump up to 2 steps right/down. First check 
matrix[0][1] as it is 1, next check 
matrix[0][2] ,this won't lead to the solution. 
Then check matrix[1][0], as this is 3(non-zero)
,so we can make 3 jumps to reach matrix[1][3]. 
From matrix[1][3] we can move downwards taking 
1 jump each time to reach destination at 
matrix[3][3].

Example 2:
Input: {{2,1,0,0},{2,0,0,1},{0,1,0,1},
{0,0,0,1}}
Output: {{-1}}
Explanation: As no path exists so, -1.
 
Your Task:
You don't need to read or print anyhting, Your task is to complete the function ShortestDistance() which takes the matrix as input parameter and returns a matrix of size n if path exists otherwise returns a matrix of 1x1 which contains -1. In output matrix, 1 at (i, j) represents the cell is taken into the path otherwise 0 if any path exists.
 
Expected Time Complexity: O(n*n*k) where k is max(matrix[i][j])
Expected Space Complexity: O(1)
 
Constraints:
1 <= n <= 50
1 <= matrix[i][j] <= 20

class Solution {
  public:
  
    bool isSafe(int i, int j, int n, vector<vector<int>>& visited, vector<vector<int>>& matrix) {
        if (i==n-1 && j==n-1) return true;
        //if (i<n && j<n && visited[i][j] == 0 && matrix[i][j] != 0) return true; //even this works
        if (i<n && j<n && matrix[i][j] != 0) return true;
        return false;
    }
    
    bool route(int i, int j, int n, vector<vector<int>>& visited, vector<vector<int>>& matrix) {
        if (i==n-1 && j==n-1) {
            visited[i][j] = 1;
            return true;
        }
        
        visited[i][j] = 1;
        for (int k=1; k<=matrix[i][j]; k++) {
            //first check if it is possible by jumping forward else check for jumping downward
            if (isSafe(i, j+k, n, visited, matrix)) {
                if (route(i, j+k, n, visited, matrix)) return true;
            }
            
            if (isSafe(i+k, j, n, visited, matrix)) {
                if (route(i+k, j, n, visited, matrix)) return true;
            }
        }
        //not possible to reach last pos mark visited as 0 and return false
        visited[i][j] = 0;
        return false;
        
    }
    
    vector<vector<int>> ShortestDistance(vector<vector<int>>& matrix) {
        // Code here
        int n = matrix.size();
        vector<vector<int>> visited(n, vector<int>(n, 0));
        if(route(0, 0, n, visited, matrix)) return visited;
        return {{-1}};
    }
};


20. Restore IP Addresses:
------------------------------
A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.

For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses, but "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.
Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.

Example 1:
Input: s = "25525511135"
Output: ["255.255.11.135","255.255.111.35"]

Example 2:
Input: s = "0000"
Output: ["0.0.0.0"]

Example 3:
Input: s = "101023"
Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
 
Constraints:
1 <= s.length <= 20
s consists of digits only.


bool isValid(string s, int startIdx, int len) {
        if (!(len > 0 && len <= 3)) return false;
        if (startIdx+len > s.size()) return false;
        if (len > 1 && s[startIdx] == '0') return false;

        // int val = 0;
        // for (int i=startIdx; i<startIdx+len; i++) {
        //     val = val*10 + s[i] - '0';
        // }
        return (atoi(s.substr(startIdx, len).c_str()) <= 255);
        //return val <= 255;
    }

    void formIP(int startIdx, int parts, string curr, string s, vector<string> &res) {
        if (parts == 4) {
            if (startIdx==s.size()) {
                curr.pop_back(); //remove trailng dot
                res.push_back(curr);
            }
            return;
        }

        for (int len=1; len<=3; len++) {
            if (isValid(s, startIdx, len)) {
                formIP(startIdx+len, parts+1, curr + s.substr(startIdx,  len)+'.', s, res);
            }
        }
    }

    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        formIP(0, 0, "", s, res);
        return res;
    }

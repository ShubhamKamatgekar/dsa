4. Longest Substring Without Repeating Characters:
---------------------------------------------------
Given a string s, find the length of the longest substring without duplicate characters.

Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.

Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 
Constraints:
0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.

class Solution {
public:
/*
    bool isValid(string s, int i, int j, vector<int>& freq) {
        for (int k=i; k<=j; k++) {
            if (freq[s[k]] > 1) return false;
        }

        return true;
    }

    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            if (isValid(s, i, j, freq)) {
                maxLen = max(maxLen, j-i+1);
            } else if (i<j){
                freq[s[i]]--;
                i++;
            }
            j++;
        }

        return maxLen;
    }
    */
//beats 100 %. everytime u inc j check if freq of jth char is > 1 if ys then kepp dec i and reduce the freq of s[i] until you overcome the duplicate char.
    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            while (freq[s[j]] > 1){
                freq[s[i]]--;
                i++;
            }
            maxLen = max(maxLen, j-i+1);
            j++;
        }

        return maxLen;
    }
};

5. Maximum Points You Can Obtain from Cards:
---------------------------------------------
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

Example 1:
Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

Example 2:
Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.

Example 3:
Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
 

Constraints:
1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length
 

Hint 1
Let the sum of all points be total_pts. You need to remove a sub-array from cardPoints with length n - k.
Hint 2
Keep a window of size n - k over the array. The answer is max(answer, total_pts - sumOfCurrentWindow)
//if yu are choosing k elements from the ends of the array u will be left with n-k elements at the center. So the max score will be max of totalscore-sum(n-k) subarray ele.


6. Find All Anagrams in a String:
---------------------------------
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

Example 1:
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
 
Constraints:
1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.


//take the window of len of p and check if freq of the window elements of s and freq of p matches. If yes append the indx to res and go ahead and inc i and dec j and update freq and check until j<s.size()

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        vector<int> freqS(26, 0);
        vector<int> freqP(26, 0);
        vector<int> res;

        for (auto c: p) {
            freqP[c-'a']++;
        }

        int n=s.size();
        int i=0;
        int j=0;

        while(j < p.size()) {
            freqS[s[j] - 'a']++;
            j++;
        }
        while(j < n) {
            if (freqS == freqP) {
                res.push_back(i);
            } 
            freqS[s[j] - 'a']++;
            freqS[s[i] - 'a']--;
            i++;
            j++;
        }

        if (freqS == freqP) {
                res.push_back(i);
        } 
        return res;
    }
};


6. Count Number of nice subarrays:
----------------------------------
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

Example 1:
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

Example 2:
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There are no odd numbers in the array.

Example 3:
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
 
Constraints:
1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length

//the approach to solve this is same as above que to find all anagrams, the important hack here is that rather than finding subarays with odd count k, we will find count of all subarrays with count atmost k and subarrays wit count atmost k-1. The final ans will be difference of these two counts
//i.e countAtmost(k) - countAtmost(k-1)


class Solution {
public:
    int countSub(vector<int>& nums, int k) {
        int i=0;
        int j=0;

        int oddcount = 0;
        int tot = 0;
        while(j < nums.size()) {
            if (nums[j]%2 == 1) oddcount++;
            while (oddcount > k) {
                if (nums[i]%2 == 1) oddcount--;
                i++;
            }

            tot += (j-i+1);  
            j++;
        }

        return tot;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return countSub(nums, k) - countSub(nums, k-1);
    }
};


9. Binary Subarrays With Sum:
-----------------------------
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

Example 1:
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

Example 2:
Input: nums = [0,0,0,0,0], goal = 0
Output: 15
 
Constraints:
1 <= nums.length <= 3 * 104
nums[i] is either 0 or 1.
0 <= goal <= nums.length

//follows the same pattern template of sliding window as above.
//add curr val of j to sum check if sum > goal dec sum with val at i and keep inc i, if i reaches n break and simply return the count if i > j, make j=i and continue else update count of subarrays by j-i+1.
//countAtmost(goal) - countAtmost(goal-1) //if goal <0 return 0.

class Solution {
public:
    int countAtmost(vector<int>& nums, int goal) {
        if (goal < 0) return 0;
        int i=0;
        int j=0;

        int sum = 0;
        int countSub = 0;
        int n = nums.size();
        while(j<nums.size()) {
            sum += nums[j];

            while(sum > goal && i<n) {
                sum -= nums[i];
                i++;
            }
            
            if (i==n) break;
            if (i>j) {
                j=i;
            } else {
                countSub += (j-i+1);
                j++;
            }
            
        }

        return countSub;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return countAtmost(nums, goal) - countAtmost(nums, goal-1);
    }
};

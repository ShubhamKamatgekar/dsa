4. Longest Substring Without Repeating Characters:
---------------------------------------------------
Given a string s, find the length of the longest substring without duplicate characters.

Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.

Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 
Constraints:
0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.

class Solution {
public:
/*
    bool isValid(string s, int i, int j, vector<int>& freq) {
        for (int k=i; k<=j; k++) {
            if (freq[s[k]] > 1) return false;
        }

        return true;
    }

    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            if (isValid(s, i, j, freq)) {
                maxLen = max(maxLen, j-i+1);
            } else if (i<j){
                freq[s[i]]--;
                i++;
            }
            j++;
        }

        return maxLen;
    }
    */
//beats 100 %. everytime u inc j check if freq of jth char is > 1 if ys then kepp dec i and reduce the freq of s[i] until you overcome the duplicate char.
    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            while (freq[s[j]] > 1){
                freq[s[i]]--;
                i++;
            }
            maxLen = max(maxLen, j-i+1);
            j++;
        }

        return maxLen;
    }
};

5. Maximum Points You Can Obtain from Cards:
---------------------------------------------
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

Example 1:
Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

Example 2:
Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.

Example 3:
Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
 

Constraints:
1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length
 

Hint 1
Let the sum of all points be total_pts. You need to remove a sub-array from cardPoints with length n - k.
Hint 2
Keep a window of size n - k over the array. The answer is max(answer, total_pts - sumOfCurrentWindow)
//if yu are choosing k elements from the ends of the array u will be left with n-k elements at the center. So the max score will be max of totalscore-sum(n-k) subarray ele.


6. Find All Anagrams in a String:
---------------------------------
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

Example 1:
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
 
Constraints:
1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.


//take the window of len of p and check if freq of the window elements of s and freq of p matches. If yes append the indx to res and go ahead and inc i and dec j and update freq and check until j<s.size()

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        vector<int> freqS(26, 0);
        vector<int> freqP(26, 0);
        vector<int> res;

        for (auto c: p) {
            freqP[c-'a']++;
        }

        int n=s.size();
        int i=0;
        int j=0;

        while(j < p.size()) {
            freqS[s[j] - 'a']++;
            j++;
        }
        while(j < n) {
            if (freqS == freqP) {
                res.push_back(i);
            } 
            freqS[s[j] - 'a']++;
            freqS[s[i] - 'a']--;
            i++;
            j++;
        }

        if (freqS == freqP) {
                res.push_back(i);
        } 
        return res;
    }
};


6. Count Number of nice subarrays:
----------------------------------
Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

Example 1:
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].

Example 2:
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There are no odd numbers in the array.

Example 3:
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
 
Constraints:
1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length

//the approach to solve this is same as above que to find all anagrams, the important hack here is that rather than finding subarays with odd count k, we will find count of all subarrays with count atmost k and subarrays wit count atmost k-1. The final ans will be difference of these two counts
//i.e countAtmost(k) - countAtmost(k-1)


class Solution {
public:
    int countSub(vector<int>& nums, int k) {
        int i=0;
        int j=0;

        int oddcount = 0;
        int tot = 0;
        while(j < nums.size()) {
            if (nums[j]%2 == 1) oddcount++;
            while (oddcount > k) {
                if (nums[i]%2 == 1) oddcount--;
                i++;
            }

            tot += (j-i+1);  
            j++;
        }

        return tot;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return countSub(nums, k) - countSub(nums, k-1);
    }
};


9. Binary Subarrays With Sum:
-----------------------------
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

Example 1:
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

Example 2:
Input: nums = [0,0,0,0,0], goal = 0
Output: 15
 
Constraints:
1 <= nums.length <= 3 * 104
nums[i] is either 0 or 1.
0 <= goal <= nums.length

//follows the same pattern template of sliding window as above.
//add curr val of j to sum check if sum > goal dec sum with val at i and keep inc i, if i reaches n break and simply return the count if i > j, make j=i and continue else update count of subarrays by j-i+1.
//countAtmost(goal) - countAtmost(goal-1) //if goal <0 return 0.

class Solution {
public:
    int countAtmost(vector<int>& nums, int goal) {
        if (goal < 0) return 0;
        int i=0;
        int j=0;

        int sum = 0;
        int countSub = 0;
        int n = nums.size();
        while(j<nums.size()) {
            sum += nums[j];

            while(sum > goal && i<n) {
                sum -= nums[i];
                i++;
            }
            
            if (i==n) break;
            if (i>j) {
                j=i;
            } else {
                countSub += (j-i+1);
                j++;
            }
            
        }

        return countSub;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return countAtmost(nums, goal) - countAtmost(nums, goal-1);
    }
};


11. Max Consecutive Ones III:
-----------------------------
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Example 2:
Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
 
Constraints:
1 <= nums.length <= 105
nums[i] is either 0 or 1.
0 <= k <= nums.length

//same as previous approach. In order to be able to convert 0's to 1's over a subarray, the subarray should only contain <= k zeros.
//so we iterate over th array, then using sliding window we check if there are max ones within the window and if any 0's are they less than k. If 0's > k shrink the window by inc i and dec zerocount if any zero at indx i. update the maxlen if current window size > maxLen

class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int i=0;
        int j=0;
        int n = nums.size();

        int zeroCount = 0;
        int maxLen = 0;

        while(j < n) {
            if (nums[j] == 0) zeroCount++;

            while(zeroCount > k) {
                if (nums[i] == 0) zeroCount--;
                i++;
            }

            maxLen = max(maxLen, j-i+1);
            j++;
        }

        return maxLen;
    }
};


16.  Longest Substring with At Most K Distinct Characters:
----------------------------------------------------------
Asked in companies - Goldman, Amazon, Uber, Google, Airbnb
Problem statement
You are given a string 'str' and an integer ‘K’. Your task is to find the length of the largest substring with at most ‘K’ distinct characters.

For example:
You are given ‘str’ = ‘abbbbbbc’ and ‘K’ = 2, then the substrings that can be formed are [‘abbbbbb’, ‘bbbbbbc’]. Hence the answer is 7.
Detailed explanation ( Input/output format, Notes, Images )

Constraints:
1 <= T <= 10
1 <= K <= 26
1 <= |str| <= 10^6

The string str will contain only lowercase alphabets.    

Time Limit: 1 sec
Note: You do not need to print anything. It has already been taken care of. Just implement the function.

Sample Input 1:
2
2
abbbbbbc
3
abcddefg
Sample Output 1:
7
4
Explanation:
For the first test case, ‘str’ = ‘abbbbbbc’ and ‘K’ = 2, then the substrings that can be formed are [‘abbbbbb’, ‘bbbbbbc’]. Hence the answer is 7.
For the second test case, ‘str’ = ‘abcddefg’ and ‘K’ = 3, then the substrings that can be formed is [‘cdde’, ‘ddef’]. Hence the answer is 4.

Sample Input 2:
2
3
aaaaaaaa
1
abcefg
Sample Output 2:
8   
1   

Hints:
1. Try to think of a brute force approach.
2. Try to think of a two-pointer solution.

//can be solved with sliding window approach. Create a map to store the freq of char in the window, if map size is > k, shrink the window  from start until map size is reduced. Update the maxLen if map size <= k.

#include<unordered_map>
#include<climits>

int kDistinctChars(int k, string &str)
{
    // Write your code here
    unordered_map<char, int> freq;

    int start = 0;
    int end = 0;
    int startIdx = 0;
    int maxLen = INT_MIN;

    while (end < str.size()) {
        freq[str[end]]++;

        while (freq.size() > k) {
            freq[str[start]]--;
            if (freq[str[start]] == 0) freq.erase(str[start]);
            start++;
        }

        if ((end-start+1) > maxLen) {
            maxLen = (end-start+1);
            startIdx = start; //if asked for returning string
        }

        end++;
    }

    return maxLen;
}


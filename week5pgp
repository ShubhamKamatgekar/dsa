4. Longest Substring Without Repeating Characters:
---------------------------------------------------
Given a string s, find the length of the longest substring without duplicate characters.

Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.

Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
 
Constraints:
0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols and spaces.

class Solution {
public:
/*
    bool isValid(string s, int i, int j, vector<int>& freq) {
        for (int k=i; k<=j; k++) {
            if (freq[s[k]] > 1) return false;
        }

        return true;
    }

    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            if (isValid(s, i, j, freq)) {
                maxLen = max(maxLen, j-i+1);
            } else if (i<j){
                freq[s[i]]--;
                i++;
            }
            j++;
        }

        return maxLen;
    }
    */
//beats 100 %. everytime u inc j check if freq of jth char is > 1 if ys then kepp dec i and reduce the freq of s[i] until you overcome the duplicate char.
    int lengthOfLongestSubstring(string s) {
        int n =s.size();
        if (n==0) return 0;
        int maxLen = 0;
        int i=0;
        int j=0;
        vector<int> freq(256, 0);

        while (j < n) {
            freq[s[j]]++;
            while (freq[s[j]] > 1){
                freq[s[i]]--;
                i++;
            }
            maxLen = max(maxLen, j-i+1);
            j++;
        }

        return maxLen;
    }
};

5. Maximum Points You Can Obtain from Cards:
---------------------------------------------
There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

Example 1:
Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

Example 2:
Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.

Example 3:
Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
 

Constraints:
1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length
 

Hint 1
Let the sum of all points be total_pts. You need to remove a sub-array from cardPoints with length n - k.
Hint 2
Keep a window of size n - k over the array. The answer is max(answer, total_pts - sumOfCurrentWindow)
//if yu are choosing k elements from the ends of the array u will be left with n-k elements at the center. So the max score will be max of totalscore-sum(n-k) subarray ele.


6. Find All Anagrams in a String:
---------------------------------
Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

Example 1:
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
 
Constraints:
1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.


//take the window of len of p and check if freq of the window elements of s and freq of p matches. If yes append the indx to res and go ahead and inc i and dec j and update freq and check until j<s.size()

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        vector<int> freqS(26, 0);
        vector<int> freqP(26, 0);
        vector<int> res;

        for (auto c: p) {
            freqP[c-'a']++;
        }

        int n=s.size();
        int i=0;
        int j=0;

        while(j < p.size()) {
            freqS[s[j] - 'a']++;
            j++;
        }
        while(j < n) {
            if (freqS == freqP) {
                res.push_back(i);
            } 
            freqS[s[j] - 'a']++;
            freqS[s[i] - 'a']--;
            i++;
            j++;
        }

        if (freqS == freqP) {
                res.push_back(i);
        } 
        return res;
    }
};
